// ------------------------------------------------------------
//      GEANT 4 template class implementation file
//
//      History: first implementation, Kevin Lynch, February 12 2010
// ----------------------------------------------------------------

#ifndef G4TNUCLEARCAPTURE_ICC
#error Do not include G4TNuclearCapture.icc directly!
#else

#include "G4TCaptureKineticsTable.hh"
#include "G4TCaptureKineticsChannel.hh"

#include "globals.hh"
#include "G4ProcessType.hh"
#include "G4HadronicProcessType.hh"
#include "G4DecayProducts.hh"

#include "G4HadronicProcessStore.hh"

#include <cmath>

template<class T>
G4TNuclearCapture<T>::G4TNuclearCapture(G4String const& name) :
  G4VRestDiscreteProcess(name, fHadronic), verboseLevel(0) {
  SetProcessSubType(fCapture);
#ifdef G4VERBOSE
  if (GetVerboseLevel()>1) {
    G4cout << "G4TNuclearCapture constructor " << "  Name:" << name << G4endl;
  }
#endif

  G4HadronicProcessStore::Instance()->RegisterExtraProcess(this);
}


template<class T>
G4TNuclearCapture<T>::~G4TNuclearCapture(){
  G4HadronicProcessStore::Instance()->DeRegisterExtraProcess(this);
}


template<class T>
G4bool G4TNuclearCapture<T>::IsApplicable(const G4ParticleDefinition& p){
  // FIXME ... Is this really the best I can do?
  try {
    dynamic_cast<T const&>(p);
    return true;
  } catch (...) {
    return false;
  }
} 

template<class T> G4double G4TNuclearCapture<T>::
PostStepGetPhysicalInteractionLength(const G4Track& track, 
				     G4double previousStepSize,
				     G4ForceCondition* condition){
   // condition is set to "Not Forced"
  *condition = NotForced;

   // pre-assigned Decay time
  G4double pTime = track.GetDynamicParticle()->GetPreAssignedDecayProperTime();
  G4double aLife = GetMeanLifeTime(track,condition);

  if (pTime < 0.) {
    // normal case 
    if ( previousStepSize > 0.0){
      // subtract NumberOfInteractionLengthLeft 
      SubtractNumberOfInteractionLengthLeft(previousStepSize);
      if(theNumberOfInteractionLengthLeft<0.){
	theNumberOfInteractionLengthLeft=perMillion;
      }
      fRemainderLifeTime = theNumberOfInteractionLengthLeft*aLife;
    }
    // get mean free path
    currentInteractionLength = GetMeanFreePath(track, previousStepSize, condition);
    
#ifdef G4VERBOSE
    if ((currentInteractionLength <=0.0) || (verboseLevel>2)){
      G4cout << "G4TNuclearCapture::PostStepGetPhysicalInteractionLength " << G4endl;
      track.GetDynamicParticle()->DumpInfo();
      G4cout << " in Material  " << track.GetMaterial()->GetName() <<G4endl;
      G4cout << "MeanFreePath = " << currentInteractionLength/cm << "[cm]" <<G4endl;
    }
#endif

    G4double value;
    if (currentInteractionLength <DBL_MAX) {
      value = theNumberOfInteractionLengthLeft * currentInteractionLength;
    } else {
      value = DBL_MAX;
    }

    return value;

  } else {
    //pre-assigned Decay time case
    // reminder proper time
    fRemainderLifeTime = pTime - track.GetProperTime();
    if (fRemainderLifeTime <= 0.0) fRemainderLifeTime = DBL_MIN;
    
    G4double  rvalue=0.0; 
    // use pre-assigned Decay time to determine PIL
    if (aLife>0.0) {
      // ordinary particle
      rvalue = (fRemainderLifeTime/aLife)*
	GetMeanFreePath(track, previousStepSize, condition);
    } else {
     // shortlived particle
      rvalue = c_light * fRemainderLifeTime;
     // by using normalized kinetic energy (= Ekin/mass)
     G4double   aMass =  track.GetDynamicParticle()->GetMass();
     rvalue *= track.GetDynamicParticle()->GetTotalMomentum()/aMass;
    }
    return rvalue;
  }
}

template<class T> G4double G4TNuclearCapture<T>::
AtRestGetPhysicalInteractionLength(const G4Track& track, 
				   G4ForceCondition* condition){
     // condition is set to "Not Forced"
  *condition = NotForced;

  G4double pTime = track.GetDynamicParticle()->GetPreAssignedDecayProperTime();
  if (pTime >= 0.) {
    fRemainderLifeTime = pTime - track.GetProperTime();
    if (fRemainderLifeTime <= 0.0) fRemainderLifeTime = DBL_MIN;
  } else {
    fRemainderLifeTime = 
      theNumberOfInteractionLengthLeft * GetMeanLifeTime(track, condition);
  }
  return fRemainderLifeTime;
}

template<class T> G4double G4TNuclearCapture<T>::
GetMeanFreePath(const G4Track& aTrack, G4double /*previousStepSize*/,
		G4ForceCondition* condition){
  const G4DynamicParticle* aParticle = aTrack.GetDynamicParticle();
  G4ParticleDefinition* aParticleDef = aParticle->GetDefinition();
  G4double aMass = aParticle->GetMass();
  G4double aLife = GetMeanLifeTime(aTrack, condition);

    // returns the mean free path in GEANT4 internal units
   G4double pathlength;
   G4double aCtau = c_light * aLife;

   // check if the particle is stable?
   if (aParticleDef->GetPDGStable()) {
     pathlength = DBL_MAX;

   //check if the particle has very short life time ?
   } else if (aCtau < DBL_MIN) { 
     pathlength =  DBL_MIN;
 
   } else {
    //calculate the mean free path 
    // by using normalized kinetic energy (= Ekin/mass)
     G4double   rKineticEnergy = aParticle->GetKineticEnergy()/aMass; 
     G4double const HighestValue = 20.0;
     if ( rKineticEnergy > HighestValue) {
       // gamma >>  1
       pathlength = ( rKineticEnergy + 1.0)* aCtau;
     } else if ( rKineticEnergy < DBL_MIN ) {
       // too slow particle
#ifdef G4VERBOSE
       if (GetVerboseLevel()>1) {
	 G4cout << "G4TNuclearCapture::GetMeanFreePath()   !!particle stops!!";
         G4cout << aParticleDef->GetParticleName() << G4endl;
	 G4cout << "KineticEnergy:" << aParticle->GetKineticEnergy()/GeV <<"[GeV]";
       }
#endif
       pathlength = DBL_MIN;
     } else {
       // beta <1 
       pathlength = (aParticle->GetTotalMomentum())/aMass*aCtau ;
     }
   }
  return  pathlength;
}

template<class T> G4double G4TNuclearCapture<T>::
GetMeanLifeTime(const G4Track& aTrack, G4ForceCondition* /*condition*/){
  // IMPLEMENT_ME/FIXME ... update the rates with material and
  // recalculate brancing ratios
  T const* muatom = 
    static_cast<T const*>( aTrack.GetDynamicParticle()->GetDefinition() );
  G4double const rate = muatom->CaptureKineticsTable()->GetTotalRate();
#ifdef G4VERBOSE
  if (GetVerboseLevel()>1) {
    G4cout << "capture rate: " << rate << "[1/ns]" << G4endl;
    G4cout << "mean life time: "<< 1./rate/ns << "[ns]" << G4endl;
  }
#endif  
  return 1./rate;
}

template<class T> void G4TNuclearCapture<T>::StartTracking(G4Track* /*aTrack*/){
  currentInteractionLength = -1.0;
  ResetNumberOfInteractionLengthLeft();
  fRemainderLifeTime = -1.0;
}

template<class T> void G4TNuclearCapture<T>::EndTracking(){
  ClearNumberOfInteractionLengthLeft();
  currentInteractionLength = -1.0;
}

template<class T> G4VParticleChange* G4TNuclearCapture<T>::
CaptureIt(const G4Track& aTrack, const G4Step& /*aStep*/){
  // The CaptureIt() method returns by pointer a particle-change object.
  // Units are expressed in GEANT4 internal units.

  //   Initialize ParticleChange
  fParticleChange.Initialize(aTrack);

  // get particle 
  const G4DynamicParticle* aParticle = aTrack.GetDynamicParticle();
  G4ParticleDefinition* aParticleDef = aParticle->GetDefinition();
  T const* muatom = static_cast<T const*>( aParticleDef );

  // get the capture table
  G4TCaptureKineticsTable<T> const* ckt = muatom->CaptureKineticsTable();

  // select a channel
  G4TCaptureKineticsChannel<T> *channel = ckt->SelectAChannel();

  G4DecayProducts *products;
  if (channel == 0 ){
    // capture channel not found
    G4Exception("G4TNuclearCapture::CaptureIt",
                "TNC0001", FatalException,
                "Can not determine a channel");    
   } else {
    // execute CaptureIt() 
#ifdef G4VERBOSE
    G4int temp = channel->GetVerboseLevel();
    if (GetVerboseLevel()>1) {
      G4cout << "G4TNuclearCapture::DoIt  : selected channel  addr:" 
	     << channel <<G4endl;
      channel->SetVerboseLevel(GetVerboseLevel());
    }
#endif
    products = channel->CaptureIt(aParticle);
#ifdef G4VERBOSE
    if (GetVerboseLevel()>1) {
      channel->SetVerboseLevel(temp);
    }
#endif
#ifdef G4VERBOSE
    if (GetVerboseLevel()>2) {
      if (! products->IsChecked() ) products->DumpInfo();
    }
#endif
  }

  // Stuff the capture products....
  
  // get parent particle information ...................................
  G4double   ParentEnergy  = aParticle->GetTotalEnergy();
  G4double   ParentMass    = aParticle->GetMass();
  if (ParentEnergy < ParentMass) {
    ParentEnergy = ParentMass;
#ifdef G4VERBOSE
    if (GetVerboseLevel()>0) {
      G4cout << "G4TNuclearCapture::CaptureIt  : "
	"Total Energy is less than its mass" << G4endl;
      G4cout << " Particle: " << aParticle->GetDefinition()->GetParticleName();
      G4cout << " Energy:"    << ParentEnergy/MeV << "[MeV]";
      G4cout << " Mass:"    << ParentMass/MeV << "[MeV]";
      G4cout << G4endl;
    }
#endif
  }
  
  G4ThreeVector ParentDirection(aParticle->GetMomentumDirection());
  
  //boost all decay products to laboratory frame
  G4double energyDeposit = 0.0;
  G4double finalGlobalTime = aTrack.GetGlobalTime();
  if (aTrack.GetTrackStatus() == fStopButAlive ){
    // AtRest case
    finalGlobalTime += fRemainderLifeTime;
    energyDeposit += aParticle->GetKineticEnergy();
  } else {
    // PostStep case
    products->Boost( ParentEnergy, ParentDirection);
  }
  
  //add products in fParticleChangeForDecay
  G4int const numberOfSecondaries = products->entries();
  fParticleChange.SetNumberOfSecondaries(numberOfSecondaries);
#ifdef G4VERBOSE
  if (GetVerboseLevel()>1) {
    G4cout << "G4TNuclearCapture::CaptureIt  : Capture vertex :";
    G4cout << " Time: " << finalGlobalTime/ns << "[ns]";
    G4cout << " X:" << (aTrack.GetPosition()).x() /cm << "[cm]";
    G4cout << " Y:" << (aTrack.GetPosition()).y() /cm << "[cm]";
    G4cout << " Z:" << (aTrack.GetPosition()).z() /cm << "[cm]";
    G4cout << G4endl;
    G4cout << "G4TNuclearCapture::CaptureIt"
      "  : capture products in Lab. Frame" << G4endl;
    products->DumpInfo();
  }
#endif
  G4int index;
  G4ThreeVector currentPosition;
  const G4TouchableHandle thand = aTrack.GetTouchableHandle();
  for (index=0; index < numberOfSecondaries; index++)
  {
     // get current position of the track
     currentPosition = aTrack.GetPosition();
     // create a new track object
     G4Track* secondary = new G4Track( products->PopProducts(),
				      finalGlobalTime ,
				      currentPosition );
     // switch on good for tracking flag
     secondary->SetGoodForTrackingFlag();
     secondary->SetTouchableHandle(thand);
     // add the secondary track in the List
     fParticleChange.AddSecondary(secondary);
  }
  delete products;

  // Kill the parent particle
  fParticleChange.ProposeTrackStatus( fStopAndKill ) ;
  fParticleChange.ProposeLocalEnergyDeposit(energyDeposit); 
  fParticleChange.ProposeGlobalTime( finalGlobalTime );
  // Clear NumberOfInteractionLengthLeft
  ClearNumberOfInteractionLengthLeft();

  return &fParticleChange ;
}

#endif
