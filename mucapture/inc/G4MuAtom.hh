#ifndef G4MuAtom_h
#define G4MuAtom_h 1

// ------------------------------------------------------------
//      GEANT 4 class header file
//
//      History: first implementation, Kevin Lynch, February 12 2010
// ----------------------------------------------------------------

#include "globals.hh"
#include "G4ParticleDefinition.hh"
#include "G4MuAtomDecayTable.hh"
#include "G4MuAtomCaptureKineticsTable.hh"

#include "G4MuonMinusAtomicCaptureCascadeModel.hh"
#include "G4MuonMinusAtomicCaptureStateModel.hh"
#include "G4MuonMinusAtomicCaptureChargeModel.hh"
#include "G4MuAtomLifetimeModel.hh"

class G4MuAtom : public G4ParticleDefinition {
  // Class Description:

  // This is a class declaring a new particle type for describing
  // muonic atoms, particularly intended for use in describing muon
  // nuclear capture processes (including Ordinary and Radiative Muon
  // Capture).  Related classes describe the muon atomic capture
  // process, muonic decay in orbit (DIO), impurity transfer from low
  // to high mass nuclei, and muon molecular formation including muon
  // catalyzed fusion.

  // In addition to the G4MuAtomDecayTable, this class adds a
  // G4CaptureKineticsTable with similar semantics; users add
  // G4CaptureKineticsChannels to implement impurity transfer and
  // capture processes of varying fidelity

public:

  virtual ~G4MuAtom();

  // These are used to explicitly instantiate a G4MuAtom; explicit
  // instantiations don't have automatically attached processes.
  // Implicitly instantiated G4MuAtoms are generated by
  // G4MuAtomTable::CreateMuAtom, which attaches the generic processes
  // and channels that the user previously attached to G4GenericMuAtom
  static G4MuAtom* MuAtom(G4int Z, G4int A, G4int iSpin=0);
  static G4MuAtom* MuAtomDefinition(G4int Z, G4int A, G4int iSpin=0);
  static G4MuAtom* Definition(G4int Z, G4int A, G4int iSpin=0);

  G4MuAtomCaptureKineticsTable* 
  CaptureKineticsTable(G4MuAtomCaptureKineticsTable*);
  G4MuAtomCaptureKineticsTable* CaptureKineticsTable() const 
  { return fCaptureTable; }

  G4MuAtomDecayTable* GetMuAtomDecayTable() const { return fMuAtomDecayTable; }
  void SetMuAtomDecayTable(G4MuAtomDecayTable* table) 
  { fMuAtomDecayTable = table; }

  G4double GetCaptureRate() const;

  static G4MuonMinusAtomicCaptureCascadeModel* 
  CascadeModel(G4int Z, G4int A, G4MuonMinusAtomicCaptureCascadeModel* m);
  static G4MuonMinusAtomicCaptureCascadeModel* 
  CascadeModel(G4int Z, G4int A);
  G4MuonMinusAtomicCaptureCascadeModel* 
  CascadeModel(G4MuonMinusAtomicCaptureCascadeModel* m);
  G4MuonMinusAtomicCaptureCascadeModel* CascadeModel() const;
  
  static G4MuonMinusAtomicCaptureStateModel* 
  StateModel(G4int Z, G4int A, G4MuonMinusAtomicCaptureStateModel* m);
  static G4MuonMinusAtomicCaptureStateModel* 
  StateModel(G4int Z, G4int A);
  G4MuonMinusAtomicCaptureStateModel* 
  StateModel(G4MuonMinusAtomicCaptureStateModel* m);
  G4MuonMinusAtomicCaptureStateModel* StateModel() const;
  
  static G4MuonMinusAtomicCaptureChargeModel* 
  ChargeModel(G4int Z, G4int A, G4MuonMinusAtomicCaptureChargeModel* m);
  static G4MuonMinusAtomicCaptureChargeModel* 
  ChargeModel(G4int Z, G4int A);
  G4MuonMinusAtomicCaptureChargeModel* 
  ChargeModel(G4MuonMinusAtomicCaptureChargeModel* m);
  G4MuonMinusAtomicCaptureChargeModel* ChargeModel() const;
  
  static G4MuAtomLifetimeModel* 
  LifetimeModel(G4int Z, G4int A, G4MuAtomLifetimeModel* m);
  static G4MuAtomLifetimeModel* LifetimeModel(G4int Z, G4int A);
  G4MuAtomLifetimeModel* LifetimeModel(G4MuAtomLifetimeModel* m);
  G4MuAtomLifetimeModel* LifetimeModel() const;
  
  // From G4MuMinusCaptureCascade
  G4double GetKShellEnergy() const;

protected:
  // We don't want people creating these things on the heap willy
  // nilly ... "protect" the constructor
  G4MuAtom(const G4String&  aName,  
	   G4double         mass,     
	   G4int            Z,
           G4int            A, 
	   G4int            iSpin,
	   G4int            encoding);

private:
  // hide the G4ParticleDefinition Decay Table ... it's not useful to
  // us, unfortunately (KRL 2012: why can't we use it?  i don't recall)
  G4DecayTable* GetDecayTable();
  void SetDecayTable(G4DecayTable*);

  G4MuAtomDecayTable *fMuAtomDecayTable;
  G4MuAtomCaptureKineticsTable *fCaptureTable;

  static G4String MakeName(G4int Z, G4int A, G4int iSpin);
  static G4int MakeEncoding(G4int Z, G4int A);
  // From G4MuMinusCaptureCascade
  G4double GetLinApprox(G4int N, 
			const G4double* X, 
			const G4double* Y, 
			G4double Xuser) const;  

  friend class G4MuAtomTable;

};



#endif
