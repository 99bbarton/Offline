// Copy of ExtinctionMonitorFNAL/test/geom_extMonFNAL.txt
// as used for the 2012-04-26 version of ROOT geometry for MARS.
// with Mu2eG4/test/extmon_fnal_v02.txt embedded.

// Full geometry for running ExtMonFNAL studies.

#include "Mu2eG4/test/geom_01_LowDetailGraphics.txt"

//################################################################
// Copy of Mu2eG4/test/extmon_fnal_v02.txt

// Extinction monitor parameters
//
// Andrei Gaponenko, 2011

bool           hasExtMonFNAL = true;

//----------------------------------------------------------------
// ExtMonFNAL detector and magnet room inside outline.  The shielding
// between the two rooms (collimator2.shielding) is defined separately.
// The magnet room is adjacent to beam dump "front" shielding, there
// is no extra wall on that side.  If we look at the plan view
// oriented so that the dump X axis points to the left and dump Z
// axis points up, the points are defined in the clockwise order
// starting from the top (touching the dump shielding) right corner.
// One coordinate is dump X, the other is dump Z shifted by
// the dump Z of the shielding surface we touch.

// This version follows the civil drawings for the outline and some sizes,
// but assumes L(magnet room)=4200, coll2 shielding = 2000, L(extmon room)=3000
// to position the stair hall and ventilation shaft
//
// The length of the stair hall is 1612 + 1219 + 1613 = 4444 mm
// Position it symmetrically about the center of coll2 shieling at Zdump=-5200:  -7422 and -2978


// // From the drawing:
// vector<double> extMonFNAL.roomInsideX = { -1750, -1750, -3731, -3731, -1750, -1750, +2822, +2822, +3584, +3584, +2822, +2822 };
// vector<double> extMonFNAL.roomInsideZ = {     0, -2928, -2928, -7422, -7422, -9200, -9200, -4200, -4200,  -796,  -796,     0};
//
// The above conflicts with ExtMonUCI location.  The easiest solution is to adjust the corner near the shaft
// to avoid the overlap.
vector<double> extMonFNAL.roomInsideX = { -1750, -1750, -3731, -3731, -1750, -1750, +2822, +2822, +3584, +3584, +1780, +1780 };
vector<double> extMonFNAL.roomInsideZ = {     0, -2928, -2928, -7422, -7422, -9200, -9200, -4200, -4200, -1700, -1700,     0 };

// The top of the room floor is assumed to be at the same level as the
// top of ProtonBeamDump "back" shielding,
// i.e. minCoreShieldingThickness above the top surface dump core.
double extMonFNAL.room.insideFullHeight = 2743;

double extMonFNAL.room.wall.thickness = 300;
double extMonFNAL.room.floor.thickness = 300;
double extMonFNAL.room.ceiling.thickness = 300;

// Amount of dirt above ExtMonFNAL room.  From drawing S-9:  6'-0'' minus ceiling thickness
double extMonFNAL.dirtOverhead.thickness = 1530;

//----------------------------------------------------------------
// The extinction monitor filter channel

// The first collimator is embedded in frontShielding of ProtonBeamDump
// and this determines its length.
//

// Transverse size of the aperture (vector since upstream and downstream halfs
// may be different):  {upstream size, downstream size}
vector<double> extMonFNAL.collimator1.channelWidth  = {50., 50.};
vector<double> extMonFNAL.collimator1.channelHeigh  = {50., 50.};
// the alignment plug:
vector<double> extMonFNAL.collimator1.alignmentPlugRadius = { 100, 177.8  };
vector<double> extMonFNAL.collimator1.alignmentHoleRClearance = { 12.7, 12.7 };
double extMonFNAL.collimator1.radiusTransitiondZ = 0;

// The entrance point on the face of the beam dump enclosure,
// transverse to the beam coordinates (horiz, vertical).  The offsets
// are w.r.t to the core center position (== the nominal beam entrance
// point).
double         extMonFNAL.entranceOffsetX = 900;
double         extMonFNAL.entranceOffsetY = 1250;

// Filter channel orientation: angles in horizontal and vertical
// planes w.r.t dump core. Note that angleH is the same for all filter
// elements, while angleV is different.  We specify angleV at the
// filter entrance.
double         extMonFNAL.angleH = 0.0856; //radians
double         extMonFNAL.entranceAngleV = 0.1645; //radians

bool extMonFNAL.collimator1.alignmentHole.visible = true;
bool extMonFNAL.collimator1.alignmentHole.solid = false;
bool extMonFNAL.collimator1.alignmentPlug.visible = true;
bool extMonFNAL.collimator1.alignmentPlug.solid = false;
bool extMonFNAL.collimator1.channel.visible = true;
bool extMonFNAL.collimator1.channel.solid = false;

//----------------------------------------------------------------
// The filter magnet room.  "Length" is along beam dump Z.
//
double extMonFNAL.magnetRoomLength = 4200.;

// The magnet
vector<double> extMonFNAL.filter.magnet.outerHalfSize = {95., 150., 1778. }; // mm
double extMonFNAL.filter.magnet.apertureWidth  =  50.; // mm
double extMonFNAL.filter.magnet.apertureHeight = 100.; // mm
string extMonFNAL.filter.magnet.material  = "G4_Fe";
double extMonFNAL.filter.magnet.fieldStrength = 0.222; // Tesla

bool extMonFNAL.filter.magnet.iron.visible = true;
bool extMonFNAL.filter.magnet.iron.solid = false;
bool extMonFNAL.filter.magnet.aperture.visible = true;
bool extMonFNAL.filter.magnet.aperture.solid = false;

// Along dump Z, the magnet is positioned with the
// {center,bottom,center} point of its aperture at
double extMonFNAL.filter.magnet.refDistanceToUpstreamWall = 2100;

// The magnet is placed in such a way that a positive particle with
// the nominal momentum given below, travelling at the bottom of
// collimator1 channel (at exit) parallel to the collimator1 axis,
// will enter the magnet aperture at the bottom and exit at at the
// bottom after being deflected by the magnetic field.
double extMonFNAL.filter.nominalMomentum = 3500.; // MeV/c
// double extMonFNAL.maxG4StepLength = 10.; // mm

//----------------------------------------------------------------
// The second collimator

// The thickness of the shielding between magnet and detector rooms.
double         extMonFNAL.collimator2.shielding.thickness = 2000.;
double         extMonFNAL.collimator2.shielding.dumpXmin  = -2050.; // to outside the wall
double         extMonFNAL.collimator2.shielding.dumpXmax  = +2822.; // touch the wall

// the downstream half of the channel is wider
vector<double> extMonFNAL.collimator2.channelWidth  = {50., 75.};
vector<double> extMonFNAL.collimator2.channelHeigh  = {50., 75.};
// the alignment plug:
vector<double> extMonFNAL.collimator2.alignmentPlugRadius = { 100, 177.8  };
vector<double> extMonFNAL.collimator2.alignmentHoleRClearance = { 12.7, 12.7 };
double extMonFNAL.collimator2.radiusTransitiondZ = 0;

bool extMonFNAL.collimator2.alignmentHole.visible = true;
bool extMonFNAL.collimator2.alignmentHole.solid = false;
bool extMonFNAL.collimator2.alignmentPlug.visible = true;
bool extMonFNAL.collimator2.alignmentPlug.solid = false;
bool extMonFNAL.collimator2.channel.visible = true;
bool extMonFNAL.collimator2.channel.solid = false;

//================================================================
// Detector location in room: the center is on the continuation of
// collimator2 center line.  Need to specify just one additional parameter.
// We use the distance along the collimator2 axis between the
// wall (inside the room surface) and reference point of the detector.
double extMonFNAL.detectorDistanceToWall = 1000;

// Details of the detector.  All of these vectors should be
// of the same size: one entry per detector plane.
// The coordinates are relative to the detector box volume.

vector<double> extMonFNAL.sensor_zoffset = {-300., -280., -50., +0, +220, +300.};
vector<double> extMonFNAL.sensor_xoffset = {0., 0., 0., 0., 0., 0.};
vector<double> extMonFNAL.sensor_yoffset = {0., 0., 0., 0., 0., 0. };

vector<double> extMonFNAL.sensor_halfdx =  { 20., 20., 20., 20., 20., 20.};
vector<double> extMonFNAL.sensor_halfdy =  { 20., 20., 20., 20., 20., 20.};
vector<double> extMonFNAL.sensor_halfdz =  { 0.2, 0.2, 0.2, 0.2, 0.2, 0.2};
vector<double> extMonFNAL.readout_halfdz = { 0.1, 0.1, 0.1, 0.1, 0.1, 0.1};

// These are detector VDs (not filter ones)
//
// Notes:
//
//    - We want to be able to look at hits in an area larger than the
//      exact sensor size, so VD transverse dimensions are additional
//      parameters.
//
//    - Because GeometryService objects are supposed to contain only
//      "physical" parameters and VDs are virtual G4-only objects,
//      these sizes are not a part of the ExtMonFNAL object.
//
bool   extMonFNAL.vd.enabled = true;
double extMonFNAL.vd.halfdx = 100; // transverse size
double extMonFNAL.vd.halfdy = 100; // transverse size

//----------------------------------------------------------------
string         extMonFNAL.room.materialName  = "G4_AIR";
string         extMonFNAL.room.wall.materialName  = "ShieldingConcrete";

bool           extMonFNAL.room.visible   = false;
bool           extMonFNAL.room.solid     = false;

bool           extMonFNAL.room.wall.visible   = true;
bool           extMonFNAL.room.wall.solid     = false;

bool           extMonFNAL.room.ceiling.visible   = true;
bool           extMonFNAL.room.ceiling.solid     = false;

bool           extMonFNAL.room.floor.visible   = true;
bool           extMonFNAL.room.floor.solid     = true;

bool extMonFNAL.collimator2.shielding.visible = true;
bool extMonFNAL.collimator2.shielding.solid = false;

bool           extMonFNAL.detectorBoxVisible   = true;
bool           extMonFNAL.detectorBoxSolid     = false;
bool           extMonFNAL.detectorPlaneVisible   = true;
bool           extMonFNAL.detectorPlaneSolid     = true;

int            extMonFNAL.verbosityLevel = 2;

// end of Mu2eG4/test/extmon_fnal_v02.txt
//################################################################




#include "Mu2eG4/test/PSShield_v01.txt"
#include "ExtinctionMonitorFNAL/test/psEnclosure_thin.txt"

// ExtMonUCI interferes with the civil construction
bool hasExtMonUCI = false;

/// ProtonBeamDumpMaker: shieldingFaceZatXmin = -16097.7, ZatXmax = -16931.4
// Using -16931.4 works for G4, but leads to problems with the exported ROOT geometry. Move farther back:
double hall.insideZExtMonUCIWall = -17200;  // to the corner of dump shielding

// From the drawing S-1:
vector<double> extMonFNAL.roomInsideX = { -1750, -1750, -3731, -3731, -1750, -1750, +2822, +2822, +3584, +3584, +2822, +2822 };
vector<double> extMonFNAL.roomInsideZ = {     0, -2928, -2928, -7422, -7422, -9200, -9200, -4200, -4200,  -796,  -796,     0 };


//int g4.steppingActionMaxSteps = 100000;
//int g4.stepsSizeLimit = 10000;
int g4.particlesSizeLimit = 100000;

// bool g4SteppingAction.killerVerbose = true;
//vector<string> g4SteppingAction.killInTheseVolumes = { "VirtualDetector_EMFC1Entrance", "VirtualDetector_Coll1_In" };

vector<string> g4SteppingAction.killInTheseVolumes = {
  "PSShield",
  "VirtualDetector_EMFC1Entrance",
  "VirtualDetector_Coll1_In",
  "ProtonBeamDumpCore",
  "HallConcreteFloor",
  "HallConcreteCeiling",
  "HallWalls"
};

double g4.minRangeCut = 1.;            // mm
bool g4.killLowEKine = true;
double g4.eKineMin = 100.; // MeV

// // Uncomment to enable debug printout on a per event or per track basis.
// vector<int> g4.steppingActionEventList = { 0, 1, 2, 3, 4, 5 };
// vector<int> g4.steppingActionTrackList = {    1, 2, 3, 4, 5 };
// vector<int> g4.trackingActionEventList = { 0, 1, 2, 3, 4, 5};

//----------------------------------------------------------------
// Tweak visibility for debugging the channel setup

bool extMonFNAL.collimator1.alignmentHole.visible = false;
bool extMonFNAL.collimator1.alignmentHole.solid = false;
bool extMonFNAL.collimator1.alignmentPlug.visible = false;
bool extMonFNAL.collimator1.alignmentPlug.solid = false;
bool extMonFNAL.collimator1.channel.visible = true;
bool extMonFNAL.collimator1.channel.solid = false;

bool extMonFNAL.collimator2.alignmentHole.visible = false;
bool extMonFNAL.collimator2.alignmentHole.solid = false;
bool extMonFNAL.collimator2.alignmentPlug.visible = false;
bool extMonFNAL.collimator2.alignmentPlug.solid = false;
bool extMonFNAL.collimator2.channel.visible = true;
bool extMonFNAL.collimator2.channel.solid = false;

bool extMonFNAL.filter.magnet.iron.visible = true;
bool extMonFNAL.filter.magnet.iron.solid = false;
bool extMonFNAL.filter.magnet.aperture.visible = true;
bool extMonFNAL.filter.magnet.aperture.solid = false;

//// change momentum setting for the debugging
//double extMonFNAL.filter.nominalMomentum = 3600.; // MeV/c
//double         extMonFNAL.entranceOffsetX = 1000;
//double         extMonFNAL.entranceOffsetY = 1250;
//double         extMonFNAL.angleH = 0.15; //0.0947; //radians
//double         extMonFNAL.entranceAngleV = 0.1644; //radians

//test: // Disable all physics except transport.
//test: string g4.physicsListName = "Minimal";
//test: //double extMonFNAL.maxG4StepLength = 10.; // mm

// double extMonFNAL.filter.magnet.deltaChord = 0.001;
// double extMonFNAL.filter.magnet.minEpsilonStep = 1.e-8;
// double extMonFNAL.filter.magnet.maxEpsilonStep = 1.e-6;
// double extMonFNAL.filter.magnet.deltaOneStep = 1.e-6;

//----------------------------------------------------------------

//// Write mu2e geometry into a GDML file
//bool   writeGDML        = true;
//bool   protonBeamDump.applyROOTVisualizationKludge = true;
//string GDMLFileName     = "extMonFNAL.gdml";

// bool   vd.visible       = true;
// bool PSShield.solid = true;

int PSShield.verbosityLevel = 1;
int protonBeamDump.verbosityLevel = 1;
int extMonFNAL.verbosityLevel = 1;
int world.verbosityLevel  = 1;
//

// This tells emacs to view this file in c++ mode.
// Local Variables:
// mode:c++
// End:
