// Update _sinTheta,_cosTheta,_sinPhi0, and _cosPhi0
inline void Helix::_refreshCache() const {
  if (_isStale) {
    _isStale=false;
    double theta;
    if ( _cotTheta==0.0 ) {
       theta = M_PI/2.0;
    }
    else {
       theta=atan(1.0/_cotTheta);
       if (theta<0.0) theta+=M_PI;
    }
    if (theta==0.0) {
      _sinTheta=0.0;
      _cosTheta=1.0;
    }
    else {
      _cosTheta=cos(theta);
      _sinTheta=sqrt(1-_cosTheta*_cosTheta);
    }
    if (_phi0==0.0) {
      _sinPhi0=0.0;
      _cosPhi0=1.0;
    }
    else {
      _cosPhi0 = cos(_phi0);
      _sinPhi0 = sqrt(1.0-_cosPhi0*_cosPhi0);
      if (_phi0>M_PI) _sinPhi0 = -_sinPhi0;
    }
  }
}

// Update _s, _aa, _ss, and _cc if the arclength has changed.
inline void Helix::_cacheSinesAndCosines(double s) const {
  _refreshCache();
  if (_s!=s){
    _s=s;
    _aa=2.0*_s*_curvature*_sinTheta;
    if (_aa==0.0) {
      _ss=0.0;
      _cc=1.0;
    }
    else {
      _ss=sin(_aa);
      _cc=cos(_aa);
    }
  }
}


inline Helix::Helix()
  :
   _cotTheta(0.0),
   _curvature(0.0),
   _z0(0.0),
   _d0(0.0),
   _phi0(0.0),
   _isStale(1),
   _sinPhi0(2),
   _cosPhi0(2),
   _sinTheta(2),
   _cosTheta(2),
   _s(-999.999),
   _aa(2),
   _ss(2),
   _cc(2),
   _vParameters(NULL),
   _centerIsValid(false),
   _m_x(0.0),
   _m_y(0.0)

{
}

inline Helix::Helix(const Helix &right)
  :_cotTheta(right._cotTheta),
   _curvature(right._curvature),
   _z0(right._z0),
   _d0(right._d0),
   _phi0(right._phi0),
   _isStale(right._isStale),
   _sinPhi0(right._sinPhi0),
   _cosPhi0(right._cosPhi0),
   _sinTheta(right._sinTheta),
   _cosTheta(right._cosTheta),
   _s(right._s),
   _aa(right._aa),
   _ss(right._ss),
   _cc(right._cc),
   _vParameters(NULL),
   _centerIsValid(right._centerIsValid),
   _m_x(right._m_x),
   _m_y(right._m_y)

{
  if (right._vParameters) {
    _vParameters=new CLHEP::HepVector(*(right._vParameters));
  }
}


inline Helix::Helix(
              double cotTheta,
              double curvature,
              double z0,
              double d0,
              Angle  phi0
            )
  :
   _cotTheta(cotTheta),
   _curvature(curvature),
   _z0(z0),
   _d0(d0),
   _phi0(phi0),
   _isStale(1),
   _sinPhi0(2),
   _cosPhi0(2),
   _sinTheta(2),
   _cosTheta(2),
   _s(-999.999),
   _aa(2),
   _ss(2),
   _cc(2),
   _vParameters(NULL),
   _centerIsValid(false),
   _m_x(0.0),
   _m_y(0.0)

{
  // Range automatically handled by Angle
  //  while(_phi0<0)       _phi0 += 2*M_PI;
  //  while(_phi0>2*M_PI)  _phi0 -= 2*M_PI;
}


// Assign the helix and the cache:
inline const Helix & Helix::operator=(const Helix &right)
{
  if (this != &right) {
    _cotTheta=right._cotTheta;
    _curvature=right._curvature;
    _z0=right._z0;
    _d0=right._d0;
    _phi0=right._phi0;
    _isStale= right._isStale;
    _sinTheta=right._sinTheta;
    _cosTheta=right._cosTheta;
    _sinPhi0=right._sinPhi0;
    _cosPhi0=right._cosPhi0;
    _s=right._s;
    _aa=right._aa;
    _ss=right._ss;
    _cc=right._cc;
    if (_vParameters) delete _vParameters;
    _vParameters=NULL;
    if (right._vParameters) {
      _vParameters = new CLHEP::HepVector(*(right._vParameters));
    }
    _centerIsValid = right._centerIsValid;
    _m_x = right._m_x;
    _m_y = right._m_y;
  }
  return *this;
}


inline void Helix::setCotTheta(double cotTheta) {
  _cotTheta=cotTheta;
  _isStale=true;
}

inline void Helix::setZ0(double z0) {
  _z0 = z0;
  _isStale=true;
}

inline void Helix::setCurvature(double curvature){
  _curvature=curvature;
  _isStale=true;
}

inline void Helix::setD0(double d0){
  _d0=d0;
  _isStale=true;
}

inline void Helix::setPhi0(Angle phi0){
  _phi0=phi0;
  // Range automatically handled by Angle
  //  while(_phi0<0)       _phi0 += 2*M_PI;
  //  while(_phi0>2*M_PI)  _phi0 -= 2*M_PI;
  _isStale=true;
}

inline void Helix::setParameters(const CLHEP::HepVector & p) {
  // Check we're getting a sensible vector
  if (p.num_row() < 5) {
    return;
  }
  setCotTheta(p[0]);
  setCurvature(p[1]);
  setZ0(p[2]);
  setD0(p[3]);
  setPhi0(p[4]);
  _isStale=true;
}
/*
inline const CLHEP::HepVector & Helix::getParameters() const {
  if (!_vParameters) _vParameters = new CLHEP::HepVector(5);
  (*_vParameters)(1)=getCotTheta();
  (*_vParameters)(2)=getCurvature();
  (*_vParameters)(3)=getZ0();
  (*_vParameters)(4)=getD0();
  (*_vParameters)(5)=getPhi0();
  return *_vParameters;;
}

inline Helix Helix::create(const CLHEP::HepVector & v)  {
  return Helix(v(1),v(2),v(3),v(4),v(5));
}
*/
inline unsigned int Helix::getParameterSpaceSize() {
  return 5;
}

#ifdef GCC_2_7

inline bool operator!=(const Helix& left, const Helix& right) {
  return !(left==right);
}

#endif //GCC_2_7

