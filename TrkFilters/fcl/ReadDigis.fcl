#
# Read Tracker digis and run the track trigger prototype 
#
#  > mu2e --config TrkFilters/fcl/ReadDigis.fcl --source "your digis file" --TFile ReadDigis.root --nevts=100
#
#include "fcl/minimalMessageService.fcl"
#include "fcl/standardServices.fcl"
#include "fcl/standardProducers.fcl"
#include "CaloCluster/fcl/prolog_trigger.fcl"
#include "TrkHitReco/fcl/prolog.fcl"
#include "TrkPatRec/fcl/prolog.fcl"


BEGIN_PROLOG
#prescale factor fot the tracker-only track triggers
# downstream e-
TPRDeMSeedFilter_evt_sf : 1
TPRDeMSeedFilter_sf     : 1
# downstream e+
TPRDePSeedFilter_evt_sf : 1
TPRDePSeedFilter_sf     : 1
#prescale factor fot the calo-seeded track triggers
# downstream e-
CPRDeMSeedFilter_evt_sf : 1
CPRDeMSeedFilter_sf     : 1
# downstream e+
CPRDePSeedFilter_evt_sf : 1
CPRDePSeedFilter_sf     : 1
END_PROLOG

#include "TrkHitReco/fcl/prolog_trigger.fcl"
#include "TrkPatRec/fcl/prolog_trigger.fcl"
#include "TrkFilters/fcl/prolog.fcl"
#include "TrkDiag/fcl/prolog.fcl"

process_name : ReadDigis

source :
{
    module_type : RootInput
}
# we don't need any simulation services for this job
services : @local::Services.Reco

services : {
    message               : @local::default_message
    TFileService          : { fileName : "readDigis.hist" }

    RandomNumberGenerator : { }
    #   Timing                : { }

    GeometryService        : { inputFile      : "Mu2eG4/geom/geom_common.txt"          }
    ConditionsService      : { conditionsfile : "Mu2eG4/test/conditions_01.txt"        }
    GlobalConstantsService : { inputFile      : "Mu2eG4/test/globalConstants_01.txt"   }
    G4Helper               : { }
    BTrkHelper             : @local::BTrkHelperDefault
    SeedService            : { @table::automaticSeeds
	baseSeed         :  0
	maxUniqueEngines :  20
    }
    
}

# timing information
services.TimeTracker : {
    dbOutput : {
	filename : "ReadDigis.db"
	overwrite : true
    }
}
# setup modules needed to filter tracks
physics :
{
    producers : {
	@table::TrkHitRecoTrigger.producers
	@table::Tracking.producers
	@table::TprTrigger.producers
	@table::CaloClusterTrigger.producers

	RSD : {
	    module_type : ReadStrawDigi
	}
	
    }
    filters : {
	@table::TrkFilters.filters
    }
    # analyzers : {
    #   TrkTriggerDiag : {
    #     module_type : TrkTriggerDiag
    #   }
    # }
}

# create a trigger test path.  Note that physics.trigger_paths and physics.end_paths are not used, art will
# create those automatically from all the defined paths

physics.TCTrigPath : [ TPRFetchDigis, @sequence::TrkFilters.sequences.TPRTC        ]

physics.PHTrigPath : [ TPRFetchDigis, @sequence::TrkFilters.sequences.TPRPosHelix  ]

physics.DeMSeedTrigPath : [ TPRFetchDigis,  @sequence::TrkFilters.sequences.TPRDeMSeed ]

#physics.DeMKalTrigPath : [ @sequence::Tracking.Trigger.DeMKal           ]
physics.DePSeedTrigPath : [ TPRFetchDigis,  @sequence::TrkFilters.sequences.TPRDePSeed ] 

# analysis path: this is for monitoring only
# physics.ReadDigisEndPath : [ TrkTriggerDiag ]

