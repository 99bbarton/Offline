//
// Main geometry file for Mu2e.
//
// $Id: geom_01.txt,v 1.217 2013/10/18 13:39:47 brownd Exp $
// $Author: brownd $
// $Date: 2013/10/18 13:39:47 $
//
// Original author Rob Kutschke
//
// Warning:  do not write 10000. as 10,000.; it will be read as two numbers (10., 0.).

string detector.name  = "g4geom_v00";

bool hasHall            = true;
bool hasTarget          = true;
bool hasProtonAbsorber  = true;
bool hasInternalNeutronAbsorber = true;
bool hasExternalNeutronShielding = true;
bool hasVaneCalorimeter = false;
bool hasDiskCalorimeter = true;
bool hasHybridCalorimeter = false;
bool hasBFieldManager   = true;
bool hasBeamline        = true;
bool hasVirtualDetector = true; // some components, e.g. ProtonAbsorber assume vd presence now;
bool hasCosmicRayShield = true;
bool hasMBS             = true; // note the two subcomponents, see mbs section below; 
                                // no MBS implies no downstream hole in Cosmic Ray Passive Shield
                                // Magnetic field may be affected as well

// Write mu2e geometry into a GDML file
bool   writeGDML        = false;
string GDMLFileName     = "mu2e.gdml";

// Uncomment exactly one tracker.
#include "Mu2eG4/test/ttracker_v2.txt"
//#include "Mu2eG4/test/ttracker_meco.txt"
//#include "Mu2eG4/test/ltracker_v0.txt"
//#include "Mu2eG4/test/itracker_v42.txt"
//#include "Mu2eG4/test/dummytracker.txt"

// Uncomment to enable debug printout on a per event or per track basis.
//vector<int> g4.steppingActionEventList = { 0, 1 };
//vector<int> g4.steppingActionTrackList = { 1 };
//vector<int> g4.strawSDEventList        = { 0, 1, 2, 3 };
//vector<int> g4.itgaslayerSDEventList   = { 0, 1, 2, 3 };
//vector<int> g4.trackingActionEventList = { 0, 1, 2, 3, 4, 5};

// Some G4 controls which does not allow it to consume all the memory
// or to spend all the time tracking one bad particle
int g4.steppingActionMaxSteps = 10000;
int g4.stepsSizeLimit = 10000;
int g4.particlesSizeLimit = 10000;
double g4.pointTrajectoryMomentumCut = 50.;


// If the following number is not zero, G4 will kill all particles alive
// at that time.
double g4.steppingActionMaxGlobalTime = 0; //ns

// The information (location, momentum) of all particles will be
// recorded in the output files for particular moments in time
//vector<double> g4.steppingActionTimeVD = { 500, 700, 1000 }; //ns

// Enable/disable code that kills uninteresting tracks in SteppingAction,
// Put a list of G4 volume names where the tracks should be killed,
// for example { "HallAir" }.
vector<string> g4SteppingAction.killInTheseVolumes = {};
bool   g4SteppingAction.killerVerbose = false;

// Do not stack neutrinos
vector<int> g4.stackingActionDropPDG = { 12, -12, 14, -14, 16, -16 };

// These are used in both SteppingAction and StackingAction.
bool   g4.killLowEKine  = false;
double g4.eKineMin      = 0.0;    // Kinetic energy in MeV

// One can set this limit particle-specific:
// vector<int>    g4.killLowEKinePDG = {211, -211,   13,  -13,   11,  -11};
// vector<double> g4.eKineMinPDG     = {9.0,  9.0, 20.0, 20.0, 95.0, 95.0};

// This setting is used for special studies (stored muons)
// bool g4.killPitchToLowToStore = false;

// current G4 stepper choices are shown below, extend Mu2eWorld.cc if more are needed
// G4ClassicalRK4
// G4ImplicitEuler
// G4ExplicitEuler
// G4SimpleRunge
// G4SimpleHeum
// G4HelixImplicitEuler
// G4HelixSimpleRunge
string g4.stepper = "G4ClassicalRK4";

// Enable the Mu2e written version of the decay of muonic atoms.
bool g4.doMuMinusConversionAtRest = false;

// Define the value of B(pi-> e nu).
// The allowed values are: { PDG, All, None, nnnnnn } where nnnnnn is any numerical value in the range [0,1]
string g4.PiENuPolicy          = PDG;
int    g4.PiENuPolicyVerbosity = 0;

// List of PDG ids of particles for which to switch off decay.
vector<int> g4.noDecay = {};

// Choose a PhysicsList and set related parameters.
string g4.physicsListName = "Shielding_MU2E01";
double g4.minRangeCut     = 0.01;            // mm

bool g4.printPhysicsProcessSummary = false;

// Enable the code to kill low p secondaries from cosmics.
bool g4.doCosmicKiller = false;
double g4.cosmicPcut = 0.;
double g4.yaboveDirtYmin = 0.;

// Load other materials defined specifically for Mu2e.
vector<string> mu2e.materials =
  { "HeavyConcrete", "ShieldingConcrete", "IsoButane", "StrawGas",
    "Kapton", "Scintillator", "WAGVacuum", "DSVacuum", "MBOverburden",
    "ITGasHe_90Isob_10", "ITGasHe_90CF4_10", "ITGasMix", "ITGasHe_75Isob_25_400mbar",
    "CarbonFiber_resin", "CarbonFiber", "PolypropyleneFoam", "CFoam", "CFoam_332", 
    "CFoam_166", "CFoam_080", "KptFoam_030", "Polyethylene", 
    "Polyethylene092B050d095", "Polyethylene092B300d119",
    "Polyethylene092Li075d106", "Polyethylene092", "Polyethylene096", "StainlessSteel", "Lyso_01",
    "A95083", "NbTi", "NbTiCu", "AL999Ni001", "C_19_H_20_O_4", "C_10_H_18_O_4",
    "C_9_H_22_N_2", "Epotek301", "G10", "SCCableInsulation", "SCCable",
    "ZirconiumHydridePolyethylene", "EGlass", "G10_FR4",
    "Polyethylene0020", "StoppingTarget_Al", "CONCRETE_MARS", "BARITE", "Half_Poly"
};

// Control printout of element and material lists.
bool g4.printElements  = false;
bool g4.printMaterials = false;

// make detector volume structure visible where enabled
bool g4.forceAuxEdgeVisible = true;

// invoke volume overlap check where enabled (draws random numbers)
bool g4.doSurfaceCheck = false;
// number of random points on the volume surface
int  g4.nSurfaceCheckPointsPercmsq =   1;
int  g4.minSurfaceCheckPoints      = 100; // per volume
int  g4.maxSurfaceCheckPoints = 10000000; // per volume

// The world volume contains a formal "hall" box that is surrounded by
// dirt at the bottom and (part way) on the sides.  The rest is filled
// with air.  The "margins" are the distances from the hall box to the
// world boundaries.   We specify the minimal allowed margins; the actual
// values may be increased to position Mu2e in the G4 world volume as
// specified by world.mu2eOriginInWorld
//
double world.minimalMargin.top = 5000;
double world.minimalMargin.bottom = 5000;
double world.minimalMargin.xmin = 5000;
double world.minimalMargin.xmax = 5000;
double world.minimalMargin.zmin = 5000;
double world.minimalMargin.zmax =  5000;
vector<double> world.mu2eOriginInWorld = { 0, 0, 0}; // mm

string world.materialName = "G4_AIR";
bool   world.boxVisible   = true;
bool   world.boxSolid     = false;
int    world.verbosityLevel = 0;

string dirt.overburdenMaterialName = "MBOverburden";

bool   world.dirt.visible         = true;
bool   world.dirt.solid           = false;

// The top surface of the world dirt is at the grade level.
// Define it with respect to the experimental hall:
double hall.floorTopDepthBelowGrade = 7620; // docdb-472v12 p12: (746'-0'' - 721'-0'')

// Positions of the hall walls
double hall.insideXmin = -7359;
double hall.insideXmax = +6250;
double hall.insideZmax = +33041;
double hall.insideXDSCorner = 0;  // Was -500, changed to accommodate CRV
double hall.insideZDSCorner = 2779;  // Zmax of TS shielding
double hall.insideXPSCorner =  964;
double hall.insideZPSCorner = -3566; // Zmin of TS shielding
double hall.insideZExtMonUCIWall = -22000; // -17129;

// docdb-472v12 p16:
// (top of ceiling =  746'-6'') - (ceiling thickness = 6'-0'') - (top of floor = 721'-0'')
//   = 19'-6'' = 5944 mm
double hall.insideFullHeight = 5944.;

// Hall wall details
double hall.floorThick   = 300.;
double hall.ceilingThick = 914.4; // 3', docdb-472v12 p16 (section "E")
double hall.innerTSCeilingThick = 762.; // accounts for 2'6" lower ceiling in
                                         // upstream TS and PS region
double hall.wallThick    = 300.;
double hall.wallExtMonUCIThick  = 600.;
string hall.wallMaterialName    = "G4_CONCRETE";
string hall.ceilingMaterialName = "G4_CONCRETE"; 
string hall.insideMaterialName  = "G4_AIR";

bool   hall.formalBoxVisible        = false;
bool   hall.formalBoxSolid          = false;

bool   hall.floorVisible            = true;
bool   hall.floorSolid              = true;
bool   hall.ceilingVisible          = true;
bool   hall.ceilingSolid            = false;
bool   hall.wallsVisible            = true;
bool   hall.wallsSolid              = false;

// Beamline shielding slabs above concrete overburden
int hall.beamlineSlabs.nSlabs = 4;
double hall.beamlineSlabs.xOffsetGlobal = -2540.; // Offset of start of bottom-most slab wrt Mu2e origin (assume -10' wrt origin)
vector<double> hall.beamlineSlabs.xOffset      = { 0., 229., 914, 2743. }; // Offsets from bottom-most slab corresponding to {0,0.75,3,9} ft
vector<double> hall.beamlineSlabs.yThicknesses = { 914.4, 914.4, 914.4, 457.2 }; // Thicknesses of slabs in mm
double hall.beamlineSlabs.zWidth               = 10973; // 36'

// This defines the vertical position of the hall air volume
double mu2e.origin.heightAboveHallFloor = 2312; // mm (728.58684' - 721')

// X-offset of the PS(+x) and DS(-x) from the Mu2e origin.
// The origin of the detector coordinate system is on the DS axis at the specified z.
double mu2e.solenoidOffset   =  3904.;   // mm
double mu2e.detectorSystemZ0 = 10200.;   // mm  G4BL: (17730-7292=9801 mm)

// Solenoids
#include "Mu2eG4/test/DetectorSolenoid_v02.txt"
#include "Mu2eG4/test/DSShielding_v01.txt"
#include "Mu2eG4/test/ProductionSolenoid_v01.txt"
#include "Mu2eG4/test/psEnclosure_v01.txt"
#include "Mu2eG4/test/PSShield_v05.txt"
#include "Mu2eG4/test/PSExternalShielding_v01.txt"
#include "Mu2eG4/test/TransportSolenoid_v01.txt"

// Neutron shielding - TS region
#include "Mu2eG4/test/ExtNeutShieldUpstream1a_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldUpstream1b_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldUpstream2_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldUpstreamTop_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldUpstreamBottom_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldCavexRight_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldCavexRightb_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldCavexLeft_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldCavexRoof_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldLAbove_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldLCeiling_v01.txt"

// Neuton shielding - DS region
#include "Mu2eG4/test/ExtNeutShieldCryoBoxes_v01.txt"
#include "Mu2eG4/test/ExtNeutShieldCendBoxes_v01.txt"

// Virtual detectors
double vd.halfLength     = 0.01; //mm
int    vd.verbosityLevel = 0;
bool   vd.visible        = true;
bool   vd.solid          = false;

// // VD right in front of a hall wall
// double vd.ExtMonCommonPlane.z = -11999.99;

#include "Mu2eG4/test/ProductionTargetInPS.txt"

#include "Mu2eG4/test/protonBeamDump_v02.txt"

#include "Mu2eG4/test/extmon_fnal_v02.txt"
#include "Mu2eG4/test/extmon_uci_v02.txt"

// Describe dummy stopping target that is just one big G4TUBS.
double dummyStoppingTarget.rIn        =     0.;
double dummyStoppingTarget.rOut       =   100.;
double dummyStoppingTarget.halfLength =   400.;
double dummyStoppingTarget.z0         =  5900.;
string dummyStoppingTarget.material   = "WAGVacuum";

//
// Describe targets.
//

// material around the targets
string         stoppingTarget.fillMaterial    = "DSVacuum";

// All dimensions in mm
double stoppingTarget.z0InMu2e       = 5871;    // 12000 - 6129
double stoppingTarget.deltaZ         = 50.0;
bool   stoppingTarget.visible        = true;
bool   stoppingTarget.solid          = false;
int    stoppingTarget.verbosity      =     0;

// all radii must be specified, i.e., nFoils is determined from the size
// of the radii vector.
vector<double> stoppingTarget.radii  =
    {  83.00,  81.89,  80.79,  79.68,  78.58,
       77.47,  76.36,  75.26,  74.15,  73.04,
       71.94,  70.83,  69.73,  68.62,  67.51,
       66.41,  65.30 };

// last material given will be repeated up to number radii.size()
//  vector<string> stoppingTarget.materials = 
//      { "G4_Al"};

// Variation of locations of foil centers
// z: variations from equal spacings according to z0 and deltaZ
// last will be repeated...
vector<double> stoppingTarget.zVars  =
    { 0., 0., 0., 0., 0.,
      0., 0., 0., 0., 0.,
      0., 0., 0., 0., 0.,
      0., 0. };

// x: relative to beam axis
// last will be repeated...
vector<double> stoppingTarget.xVars  =
    { 0.};

// y: relative to beam axis
// last will be repeated...
vector<double> stoppingTarget.yVars  =
    { 0. };

// last thickness given will be repeated up to number radii.size()
vector<double> stoppingTarget.halfThicknesses  =
    {0.1};

// last x directional cosine given will be repeated up to number radii.size()
vector<double> stoppingTarget.xCos  =
    { 0.};

// last y directional cosine given will be repeated up to number radii.size()
vector<double> stoppingTarget.yCos  =
    { 0.};

// stopping foil target supporting structure
bool   stoppingTarget.foilTarget_supportStructure = true;
int    stoppingTarget.foilTarget_supportStructure_number = 3; // number of support wires per foil
double stoppingTarget.foilTarget_supportStructure_angleOffset = 0; // angle of first support wire wrt vertical
double stoppingTarget.foilTarget_supportStructure_radius = 0.0381; // radius of the support wires, 38.1micrometer radius corresponds to 3mil diameter
string stoppingTarget.foilTarget_supportStructure_fillMaterial = "G4_W";


// Crystal calorimeter
#include "Mu2eG4/test/calorimeter.txt"

double          crs.scintillatorBarLengthDSR     =  4527;
double          crs.scintillatorBarLengthDSL     =  4527;
double          crs.scintillatorBarLengthDST     =  5600;
double          crs.scintillatorBarLengthDSD     =  5600;
double          crs.scintillatorBarLengthTSR     =  4527;
double          crs.scintillatorBarLengthTSL     =  4527;
double          crs.scintillatorBarLengthTST     =  5345;
double          crs.scintillatorBarThickness     =  20;
double          crs.scintillatorBarWidth         =  50;
double          crs.layerOffset                  =  10;  //mm
double          crs.gapLarge                     =  3;   //mm
double          crs.gapSmall                     =  0;   //mm
double          crs.gapBetweenLayers             =  5.4; //mm
int             crs.nLayers                      =  4;
int             crs.nModulesDSR                  =  34;
int             crs.nModulesDSL                  =  26;
int             crs.nModulesDST                  =  35;
int             crs.nModulesDSD                  =  4;
int             crs.nModulesTSR                  =  11;
int             crs.nModulesTSL                  =  2;
int             crs.nModulesTST                  =  2;
int             crs.nCountersPerModule           =  12;  //at one layer
int             crs.nCountersLastModuleDSR       =  7;  //at one layer
int             crs.nCountersLastModuleDSL       =  7;
int             crs.nCountersLastModuleDST       =  8;
int             crs.nCountersLastModuleDSD       =  6;
int             crs.nCountersLastModuleTSR       =  8;
int             crs.nCountersLastModuleTSL       =  8;
int             crs.nCountersLastModuleTST       =  6;
vector<double>  crs.firstCounterDSR              =  {-6460,    263.5, -2225}; //in mu2e coordinates
vector<double>  crs.firstCounterDSL              =  {-1348,    263.5,  2720};
vector<double>  crs.firstCounterDST              =  {-3904,   2637,   -2475};
vector<double>  crs.firstCounterDSD              =  {-3904,   2472,   18575};
vector<double>  crs.firstCounterTSR              =  {-6679,    263.5, -2360};
vector<double>  crs.firstCounterTSL              =  {-1146.8,  263.5,  2705};
vector<double>  crs.firstCounterTST              =  {-1079,   2637,     172.5};
string          crs.scintillatorBarMaterialName  = "G4_POLYSTYRENE";

bool   crs.vetoVisible    = true;
bool   crs.vetoSolid      = true;
int    crs.verbosityLevel = 0;




// Magnetic field
// default is now Mau9 everywhere, including the DS
// Form of DS field: 0 is full field;
//                   1 is full upstream, const downstream;
//                   2 is const throughout
int detSolFieldForm = 0;
// Mau 9 maps
vector<string> bfield.innerMaps = {
  "BFieldMaps/Mau9/Mu2e_DSMap.header",
  "BFieldMaps/Mau9/Mu2e_PSMap.header",
  "BFieldMaps/Mau9/Mu2e_TSuMap.header",
  "BFieldMaps/Mau9/Mu2e_TSdMap.header",
  "BFieldMaps/Mau9/PStoDumpAreaMap.header",
  "BFieldMaps/Mau9/ProtonDumpAreaMap.header",
  "BFieldMaps/Mau9/DSExtension.header"
};

// Value of the uniform magnetic field with the DS volume (only for
// detSolFieldForm>0)
double toyDS.bz            = 1.0;

// Gradient of field in DS2 volume. Applied only in the case
// of detSolFieldForm=1 or detSolFieldForm=2.
double toyDS.gradient      = 0.0; // Tesla/m

// This is recommended field map. See geom_mecofield.txt to use the meco field.
string bfield.format  = "G4BL";

// The other option is "meco"
string bfield.interpolationStyle = trilinear;

int  bfield.verbosityLevel =  0;
bool bfield.writeG4BLBinaries     =  false;

vector<string> bfield.outerMaps = {
  "BFieldMaps/Mau9/ExtMonUCIInternal1AreaMap.header",
  "BFieldMaps/Mau9/ExtMonUCIInternal2AreaMap.header",
  "BFieldMaps/Mau9/ExtMonUCIAreaMap.header",
  "BFieldMaps/Mau9/PSAreaMap.header"
};

// This scale factor is of limited use.
// It can make approximate sense to scale the PS field to get a rough
// answer; the answer will be wrong in detail.
// It never makes sense to scale the TS field.
// Not sure if it ever makes sense to scale the PS field.
double bfield.scaleFactor = 1.0;

// Proton Absorber
#include "Mu2eG4/test/protonAbsorber_conical_v2.txt"
// use following line instead of above line to go back to MECO-style PA design
//#include "Mu2eG4/test/protonAbsorber_conical.txt"
// use following line to use helical PA instead of above line
//#include "Mu2eG4/test/protonAbsorber_helical.txt"

// Neutron Absorber (document draft dated 2010-07-16)

double intneutronabs.rOut        = 940.; // 1cm clearance between INS and DS cryo. 
double intneutronabs.r4		 = 447; // outer radius, inner radius is TS5
double intneutronabs.rIn3        = 890.;
double intneutronabs.rIn2        = 850.;
double intneutronabs.rIn1        = 650.;
double intneutronabs.halfLength4 = 25.0;
double intneutronabs.halfLength3 = 2000.;
double intneutronabs.halfLength2 = 1000.;
double intneutronabs.halfLength1 = 500.;
double intneutronabs.z0          = 5871.;
string intneutronabs.material1Name = "Polyethylene092B050d095";
string intneutronabs.material2Name = "Polyethylene092B050d095";
// piec 2 and 3 of the INA are experimental, for now turn them off
string intneutronabs.material3Name = "DSVacuum";
string intneutronabs.material4Name = "Polyethylene092B050d095";

int    intneutronabs.verbosityLevel = 0;
bool   intneutronabs.visible      = true;
bool   intneutronabs.solid        = false;

string extneutronabs.materialName  = "Polyethylene092Li075d106";
double extneutronabs.halfLengthZ   = 6220.0;
double extneutronabs.halfLengthXY  = 1475.0;
double extneutronabs.halfThickness =   75.0;
double extneutronabs.z0            = 9219.0; // 2999+15439/2

int    extneutronabs.verbosityLevel = 0;
bool   extneutronabs.visible      = true;
bool   extneutronabs.solid        = false;

// Muon Beam Dump/Stop

// except for one of the Z offset values the rest is computable from the other values

// the Z values were adjusted from mu2e doc-1351 based on doc-1186 also to
// fit with the previously implemented components

// the initial implementation is described in doc-1519

double mbs.MBSCZ              = 15258.0;

double mbs.BSTSInnerRadius    =   470.0;
double mbs.BSTSOuterRadius    =   480.0;
double mbs.BSTSHLength        =  2058.0;
string mbs.BSTSMaterialName   = "StainlessSteel";
double mbs.BSTSZrelCntr       =     0.0;

double mbs.SPBSSup1InnerRadius  =   480.0;
double mbs.SPBSSup1OuterRadius  =   700.0;
double mbs.SPBSSup1HLength      =    20.0;
string mbs.SPBSSup1MaterialName = "StainlessSteel";
double mbs.SPBSSup1ZrelCntr     =  -878.0;
double mbs.SPBSSup2InnerRadius  =   480.0;
double mbs.SPBSSup2OuterRadius  =   700.0;
double mbs.SPBSSup2HLength      =    20.0;
string mbs.SPBSSup2MaterialName = "StainlessSteel";
double mbs.SPBSSup2ZrelCntr     =  662.0;

double mbs.SPBSLInnerRadius   =   480.0;
double mbs.SPBSLOuterRadius   =   700.0;
double mbs.SPBSLHLength       =   300.0;
string mbs.SPBSLMaterialName  = "Polyethylene096";
double mbs.SPBLZrelCntr       = -1198.0;
double mbs.SPBSCInnerRadius   =   480.0;
double mbs.SPBSCOuterRadius   =   640.0;
double mbs.SPBSCHLength       =   750.0;
double mbs.SPBSCminAngle      =   -67.5;
double mbs.SPBSCmaxAngle      =   247.5;
string mbs.SPBSCMaterialName  = "Polyethylene096";
double mbs.SPBCZrelCntr       =  -108.0;
double mbs.SPBSRInnerRadius   =   480.0;
double mbs.SPBSROuterRadius   =   700.0;
double mbs.SPBSRHLength       =   280.0;
string mbs.SPBSRMaterialName  = "Polyethylene096";
double mbs.SPBRZrelCntr       = 962.0;

vector<double> mbs.BSTCInnerRadii  =   { 390.0, 320.0 }; 
vector<double> mbs.BSTCOuterRadii  =   { 470.0, 470.0 };
vector<double> mbs.BSTCLengths     =   { 600.0, 600.0 };
string mbs.BSTCMaterialName   = "Polyethylene096";
double mbs.BSTCZrelCntr       =  -1458.0;

vector<double> mbs.BSBSInnerRadii  =   { 370.0, 320.0 };
vector<double> mbs.BSBSOuterRadii  =   { 470.0, 470.0 };
vector<double> mbs.BSBSLengths     =   { 1516.0, 1400.0 };
string mbs.BSBSMaterialName   = "Polyethylene096";
double mbs.BSBSZrelCntr            =  600.0;

vector<double> mbs.CLV2InnerRadii  =   {  40.0 };
vector<double> mbs.CLV2OuterRadii  =   { 320.0 };
vector<double> mbs.CLV2Lengths     =   { 240.0 };
string mbs.CLV2MaterialName   = "Polyethylene096";
double mbs.CLV2ZrelCntr            =  1938.0;

int    mbs.verbosityLevel = 0;
bool   mbs.visible      = true;
bool   mbs.solid        = false;

//
//
// End notes:
//
// 1) Sources of information:
//
//
//
// This tells emacs to view this file in c++ mode.
// Local Variables:
// mode:c++
// End:
