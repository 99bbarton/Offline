//
// Main geometry file for Mu2e.
//
// $Id: geom_01.txt,v 1.50 2010/09/21 21:54:31 avdhesh Exp $
// $Author: avdhesh $
// $Date: 2010/09/21 21:54:31 $
//
// Original author Rob Kutschke
//
// Warning:  do not write 10000. as 10,000.; it will be read as two numbers (10., 0.).

string detector.name  = "g4geom_v00";

bool hasHall          = true;
bool hasTarget        = true;
bool hasProtonAbsorber  = true;
bool hasCalorimeter   = true;
bool hasBFieldManager = true;
bool hasVirtualDetector = false;

// Uncomment exactly one tracker.
#include "Mu2eG4/test/ttracker_v0.txt"
//#include "Mu2eG4/test/ttracker_meco.txt"
//#include "Mu2eG4/test/ltracker_v0.txt"
//#include "Mu2eG4/test/itracker_v0.txt"
//#include "Mu2eG4/test/dummytracker.txt"

// Uncomment to enable debug printout on a per event or per track basis.
//vector<int> g4.steppingActionEventList = { 0, 1 };
//vector<int> g4.steppingActionTrackList = { 156, 157, 158 };
//vector<int> g4.strawSDEventList        = { 0, 1, 2, 3 };
//vector<int> g4.trackingActionEventList = { 0, 1, 2, 3, 4, 5};

// Enable/disable code that kills uninteresting tracks in SteppingAction or TrackingAction.
bool   g4SteppingAction.killLowEKine  = false;
bool   g4SteppingAction.killInHallAir = false;
bool   g4SteppingAction.killerVerbose = false;
double g4SteppingAction.eKineMin      = 0.1;    // Kinetic energy in MeV

//form of DS field: 0 is full field; 1 is full upstream, const downstream; 2 is const throughout
int detSolFieldForm = 2;

// current G4 stepper choices are shown below, extend Mu2eWorld.cc if more are needed

// G4ClassicalRK4
// G4ImplicitEuler
// G4ExplicitEuler
// G4SimpleRunge
// G4SimpleHeum
// G4HelixImplicitEuler
// G4HelixSimpleRunge

// the default is G4SimpleRunge

string g4.stepper = "G4SimpleRunge";

// Print a copy of this file to the job log.
bool printConfig = false;

//  Print statistics about this file to the job log.
bool printConfigStats = false;

// Choose a PhysicsList
string g4.physicsListName = "N02";

// Enable the code to kill low p secondaries from cosmics.
bool g4.doCosmicKiller = false;

// Tell G4 to load these predefined elements.
vector<string> g4.elements =
  { "H",  "He", "C",  "N",  "O",  "F", "Na", "Al", "Si", "Ar",
    "Ca", "Ti", "Fe", "Cu", "Ta", "W", "Pt", "Au", "Pb", "Ag" };
 
// Tell G4 to load these predefined materials.
vector<string> g4.materials =
  { "G4_H",     "G4_He",  "G4_C",  "G4_N",  "G4_O", 
    "G4_F",     "G4_Na",  "G4_Al", "G4_Si", "G4_Ar",
    "G4_Ca",    "G4_Ti",  "G4_Fe", "G4_Cu", "G4_Ta",
    "G4_W",     "G4_Pt",  "G4_Au", "G4_Pb", "G4_WATER",
    "G4_PbWO4", "G4_AIR", "G4_Ag", "G4_Be"
  };

// Load other materials defined specifically for Mu2e.
vector<string> mu2e.materials =
  { "ShieldingConcrete", "Polyethylene", "IsoButane", "StrawGas", 
    "Kapton", "Scintillator", "WAGVacuum", "MBOverburden", 
    "ITGasMix",  "CarbonFiber", "PolypropyleneFoam" };

// Control printout of element and material lists.
bool g4.printElements  = false;
bool g4.printMaterials = false;

// make detector volume structure visible where enabled
bool g4.forceAuxEdgeVisible = true;
// invoke volume overlap check where enabled (draws random numbers)
bool g4.doSurfaceCheck = false;

// Half lengths of the world box, (x,y,z) in mm.
vector<double> world.halfLengths  = { 20000., 10000., 20000.};
string         world.materialName = "G4_AIR";
bool           world.boxVisible   = true;
bool           world.boxSolid     = false;


// Position of the origin of the Mu2e origin system at the 
//  x: mid-point between TSu and TSd.
//  y: given as height above the floor
//  z: offset from the world origin.
double world.mu2eOrigin.xoffset =     0.;
double world.mu2eOrigin.height  =  2350.;
double world.mu2eOrigin.zoffset = -4000.;

// Overburden above the detector: 20 ft in proposal.
// I have arbitrarily split it into a flat part and a dome.
double dirt.overburdenDepth = 6000.;  
double dirt.capHalfHeight   = 1.; // small numbers make it "almost" invisible (mm)
double dirt.capBottomRadius = 2.;
double dirt.capTopRadius    = 1.;
string dirt.overburdenMaterialName = "MBOverburden";
bool   dirt.visible         = true;
bool   dirt.solid           = false;
bool   dirt.capVisible      = true;
bool   dirt.capSolid        = false;

// Inside dimensions of the hall.  Order is: (x,y,z) = width, height, length.
// Thicknesses of the hall walls.
vector<double> hall.insideHalfLengths = { 7775., 5000., 16000.};
double hall.floorThick   = 300.;
double hall.ceilingThick = 300.;
double hall.wallThick    = 300.;
string hall.wallMaterialName = "G4_CONCRETE";
string hall.insideMaterialName = "G4_AIR";
bool   hall.visible            = true;
bool   hall.solid              = false;

// Offset of the hall from its base position within the world:
//   - Centered in x and z.
//   - At the bottom in y.
vector<double> hall.offset = { -1525., 0., 0. };

// X-offset of the PS(+x) and DS(-x) from the Mu2e origin.
double mu2e.solenoidOffset = 3904.;

// A toy model of the DS, cyrostats+coils, vacuum
double toyDS.rIn                = 1000;
double toyDS.rOut               = 1300;
double toyDS.halfLength         = 6000.;
double toyDS.z0                 = 9226.;
double toyDS1.halfLength        =  150.;
double toyDS2.halfLength        = 2350.;
double toyDS3.halfLength        = 3650.;
double toyDS.frontHalfLength    =  150.;
string toyDS.materialName       = "G4_Al";
string toyDS.insideMaterialName = "WAGVacuum";
bool   toyDS.visible            = true;
bool   toyDS.solid              = true;

// Use a uniform magnetic field with the DS volume.
double toyDS.bz            = -1.0;

// A toy model of the PS, coils, cryo and vaccum.
double toyPS.rIn            =   880.;
double toyPS.rOut           =  1300.;
double toyPS1.vacHalfLength =  2580.; //2700.;
double toyPS.CryoHalfLength =  2580.;
string toyPS.materialName   = "G4_Al";
bool   toyPS.visible        = true;
bool   toyPS.solid          = true;

// Parameters for TS volumes.
double toyTS.rVac        =  240.;          // Outer radius of vacuum volume
double toyTS.rCryo       =  700.;          // Outer radius of cryostat
double toyTS.rTorus      = 2926.;          // Bend radius of the torus
double toyTS1.halfLength =  500.;
double toyTS5.halfLength =  500.;
bool   toyTS.visible        = true;
bool   toyTS.solid          = true;

// PBAR Absorber

double pbar.halfLength = 60.0e-3;
string pbar.materialName = "G4_Be";

// Collimators

bool   coll.visible        = true;
bool   coll.solid          = true;

double coll1.halfLength = 500.0;
double coll1.innerRadius1 = 150.0;
double coll1.innerRadius2 = 170.0;
string coll1.materialName = "G4_Cu";

double coll3.halfLength = 400.0;
double coll3.hole = 50.0;
double coll3.rotationAngle = 0.0;
string coll3.materialName = "G4_Cu";
vector<double> coll3.x = { 0.0,     25.09,  49.9,   74.16,  97.62, 120.0, 141.07, 160.59, 178.35, 194.16, 
			   207.85, 219.25, 228.25, 234.76, 238.69, 240.0, 238.69, 234.76, 228.25, 219.25,
			   207.85, 194.16, 178.35, 160.59, 141.07, 120.0,  97.62,  74.16,  49.9,   25.09,
			   0.0,      0.0,  111.8,  118.8,  125.16, 130.85, 135.85, 140.13, 143.66, 146.42,
			   148.41, 149.6,  150.0,  149.6,  148.41, 146.42, 143.66, 140.13, 135.85, 130.85,
			   125.16, 118.8, 111.8,     0.0 };
vector<double> coll3.y = { 240.0,  238.685, 234.755, 228.254, 219.251, 207.846, 194.164, 178.355, 160.591, 141.068, 
			   120.0,   97.617,  74.164,  49.899,  25.087,   0.0,   -25.087, -49.899, -74.164, -97.617, 
			   -120.0,-141.068,-160.591,-178.355,-194.164,-207.846,-219.251,-228.254,-234.755,-238.685, 
			   -240.0, -190.0, -190.0,  -181.583,-172.678,-163.333,-153.597,-143.523,-133.165,-122.576, 
			   -111.814,-100.936,-90.0,  -79.064, -68.186, -57.424, -46.835, -36.477, -26.403, -16.667, 
			   -7.322, 1.583, 10.0, 10.0 };


double coll5.halfLength   = 500.0;
double coll5.innerRadius  = 128.0;
string coll5.materialName = "G4_Cu";

// Virtual detectors

double vd.halfLength     = 0.1; //mm
bool   vd.visible        = true;
bool   vd.solid          = true;

// Production Target in PS:

// Position in the Mu2e coordinate system
vector<double> productionTarget.position = { 3904., 0., -6564.5};

double targetPS_halfLength        =     80.;  // mm.
double targetPS_rOut              =      3.;  // mm
double targetPS_positionX         =      0.;  // mm
double targetPS_positionY         =      0.;  // mm
double targetPS_positionZ         =   -35.5;  // mm
double targetPS_rotX              =    -1.8;  // degree. Active rotation. See Mu2e-doc-938.
double targetPS_rotY              =   12.22;  // degree.
string targetPS_materialName      = "G4_Au";
bool   targetPS.visible           = true;
bool   targetPS.solid             = true;

// Describe dummy stopping target that is just one big G4TUBS.
double dummyStoppingTarget.rIn        =     0.;
double dummyStoppingTarget.rOut       =   100.;
double dummyStoppingTarget.halfLength =   400.;
double dummyStoppingTarget.z0         =  5900.;
string dummyStoppingTarget.material   = "WAGVacuum";

//
// Describe targets.  
//

// material around the targets
string         target.fillMaterial    = "WAGVacuum";

// All dimensions in mm in the detector coordinate system.
// (0,0,0) = on axis in the DS at z=12000. mm
double target.z0             = -6100.0;
double target.deltaZ         =    50.0;
bool   target.visible        = true;
bool   target.solid          = true;

// all radii must be specified, i.e., nFoils is determined from the size 
// of the radii vector.
vector<double> target.radii  = 
    { 100.000, 82.168, 81.288, 80.378, 79.438,
       78.467, 77.463, 76.425, 75.352, 74.241,
       73.093, 71.904, 70.674, 69.401, 68.082,
       66.716, 65.300 };

// last material given will be repeated up to number radii.size()
vector<string> target.materials =
    { "G4_Al"};

// Variation of locations of foil centers 
// z: variations from equal spacings according to z0 and deltaZ
// last will be repeated...
vector<double> target.zVars  =    
    { 0., 0., 0., 0., 0.,
      0., 0., 0., 0., 0.,
      0., 0., 0., 0., 0.,
      0., 0. };

// x: relative to beam axis
// last will be repeated...
vector<double> target.xVars  =    
    { 0.};

// y: relative to beam axis
// last will be repeated...
vector<double> target.yVars  =    
    { 0. };

// last thickness given will be repeated up to number radii.size()
vector<double> target.halfThicknesses  =    
    {0.1};

// last x directional cosine given will be repeated up to number radii.size()
vector<double> target.xCos  =    
    { 0.};

// last y directional cosine given will be repeated up to number radii.size()
vector<double> target.yCos  =    
    { 0.};

// Crystal calorimeter - MECO style.
double calorimeter.innerRadius  = 360.;
double calorimeter.outerRadius  = 720.;
double calorimeter.halfLength   = 770.;
string calorimeter.fillMaterial = "WAGVacuum";
double calorimeter.z0           = 12700.;


// calorimeter 
int    calorimeter.numberOfVanes                           =  4;
double calorimeter.crystalHalfTrans                        = 15.; 
double calorimeter.crystalHalfLong                         = 60.;
int    calorimeter.nCrystalRSlices                         =  2;
int    calorimeter.nCrystalZSlices                         =  2;
vector<double> calorimeter.calorimeterCenter               = {0.,0.,12700.};
vector<double> calorimeter.calorimeterCenterOffset         = {0.,0.,0.};
double calorimeter.rInscribed                              = 360.;
double calorimeter.phi0                                    =  0.;
double calorimeter.theta0                                  =  0.;
vector<double> calorimeter.calorimeterVaneRotationsPhi     = {0.,0.,0.,0.};
vector<double> calorimeter.calorimeterVaneRotationsTheta   = {0.,0.,0.,0.};
vector<double> calorimeter.calorimeterVaneRotationsPsi     = {0.,0.,0.,0.};
vector<double> calorimeter.calorimeterVaneOffsetsX         = {0.,0.,0.,0.};
vector<double> calorimeter.calorimeterVaneOffsetsY         = {0.,0.,0.,0.};
vector<double> calorimeter.calorimeterVaneOffsetsZ         = {0.,0.,0.,0.};
string calorimeter.crystalMaterial                         = "G4_PbWO4";
string calorimeter.crystalWrapper                          = "G4_POLYETHYLENE"; // until I get around to defining Tyvek with Ti02.
string calorimeter.calorimeterFillMaterial                 = "WAGVacuum";

double calorimeter.crystalWrapperHalfThickness             = 0.01 ;             // totally made up

string calorimeter.crystalReadoutMaterial                  = "G4_Si";
double calorimeter.crystalReadoutHalfTrans                 = 15.;
double calorimeter.crystalReadoutHalfThickness             = 10.; 
int    calorimeter.crystalReadoutChannelCount              = 1;                 // number of APD's for example per crystal
bool   calorimeter.visible        = true;
bool   calorimeter.solid          = true;

// Dimensions of CRV steel, assuming constant thickness all around, and square shape.
double fluxcrv.HallSteelHalfThick    = 250.;
double fluxcrv.HallSteelHalfLengthXY = 2048.;
double fluxcrv.HallSteelHalfLengthZ  = 7150.;
string fluxcrv.HallSteelMaterialName = "G4_Fe";
double fluxcrv.HallSteelHoleRadius   = 850;
vector<double> fluxcrv.HallSteelOffset  = {0.,0., -80.}; // mm
bool   fluxcrv.visible          = true;
bool   fluxcrv.solid            = false;

// Magnetic field
string bfield.dsFile = "/grid/fermiapp/mu2e/mu2e/BFieldMaps/MECO/dsmap_unfmt_rad100.dat";
vector<int> bfield.dsDimensions = {  50, 25, 438 };
string bfield.tsFile = "/grid/fermiapp/mu2e/mu2e/BFieldMaps/MECO/tsmap_unfmt_rotcor.dat";
vector<int> bfield.tsDimensions = { 425, 18, 388 };
string bfield.psFile = "/grid/fermiapp/mu2e/mu2e/BFieldMaps/MECO/psmap_unfmt.dat";
vector<int> bfield.psDimensions = {  76, 38, 251 };

// Proton Absorber
string protonabsorber.materialName = "G4_POLYETHYLENE";
double protonabsorber.InRadius1    =  384.7;
double protonabsorber.OutRadius1   =  385.2;
double protonabsorber.InRadius0    =  334.7;
double protonabsorber.OutRadius0   =  335.2;
double protonabsorber.halfLength   = 1250.0;
double protonabsorber.thickness    =    0.5;
bool   protonabsorber.visible      = true;
bool   protonabsorber.solid        = true;

//
//
// End notes:
// 
// 1) Sources of information:
//    
//
//
// This tells emacs to view this file in c++ mode.
// Local Variables:
// mode:c++
// End:
