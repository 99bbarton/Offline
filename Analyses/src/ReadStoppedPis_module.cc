//
// An EDAnalyzer module that reads back the stopped pi info generated by G4 
// and makes histograms.
//
// $Id: ReadStoppedPis_module.cc,v 1.1 2012/05/30 16:12:02 mf Exp $
//
// Original author M Fischler
//

#include "CLHEP/Units/SystemOfUnits.h"
#include "ConditionsService/inc/GlobalConstantsHandle.hh"
#include "ConditionsService/inc/ParticleDataTable.hh"
#include "ConditionsService/inc/unknownPDGIdName.hh"
#include "GeometryService/inc/GeomHandle.hh"
#include "GeometryService/inc/GeometryService.hh"
#include "GeometryService/inc/getTrackerOrThrow.hh"
#include "ITrackerGeom/inc/ITracker.hh"
#include "MCDataProducts/inc/GenParticleCollection.hh"
#include "MCDataProducts/inc/PhysicalVolumeInfoCollection.hh"
#include "MCDataProducts/inc/SimParticleCollection.hh"
#include "MCDataProducts/inc/PDGCode.hh"
#include "MCDataProducts/inc/StatusG4.hh"
#include "MCDataProducts/inc/StatusG4.hh"
#include "MCDataProducts/inc/StepPointMCCollection.hh"
#include "MCDataProducts/inc/PtrStepPointMCVectorCollection.hh"
#include "Mu2eUtilities/inc/TwoLinePCA.hh"
#include "TDirectory.h"
#include "TGraph.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TNtuple.h"
#include "TTrackerGeom/inc/TTracker.hh"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Principal/Handle.h"
#include "cetlib/exception.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include <cmath>
#include <iostream>
#include <string>

using namespace std;

using CLHEP::Hep3Vector;
using CLHEP::keV;

namespace mu2e {

  class ReadStoppedPis : public art::EDAnalyzer {
  public:

    explicit ReadStoppedPis(fhicl::ParameterSet const& pset);
    virtual ~ReadStoppedPis() { }

    virtual void beginJob();
    virtual void endJob();

    // This is called for each event.
    virtual void analyze(const art::Event& e);

  private:

    // Start: run time parameters

    // Diagnostics printout level
    int _diagLevel;

    // Module label of the g4 module that made the hits
    //   The hits going to the stopping target
    std::string _g4ModuleLabel;
    //   The hits from VD5
    std::string _g4VD5ModuleLabel;

    // Module label of the generator module that was passed as input to G4.
    std::string _generatorModuleLabel;

   // Name of the stopping target StepPoint collection
    std::string _targetStepPoints;

    // Cut on the minimum energy.
    double _minimumEnergy;

    // Limit on number of events for which there will be full printout.
    int _maxFullPrint;

    // Limit the size of the TGraph.
    int _xyHitsMax;

    // End: run time parameters

    // Number of events analyzed.
    int _nAnalyzed;

    // Control of which particles to put into the ntuple
    bool _pionsOnly;
    bool _primariesOnly;

    // Pointers to histograms, ntuples, TGraphs.

    TH1F* _hTargetEdep;
    TH1F* _hTargetPathLength;
    TH1F* _hTargetNfoils;
    TH2F* _hTargetNfoils2D;

    TNtuple* _ntup;
    TNtuple* _pionTargNtup;

    TGraph*  _xyHits;

    // Need to keep track of TGraph entries by hand.
    int _xyHitCount;

    // Other class variables
    int _nBadG4Status;
    int _nBadSimsAtTargetHandle;
    
    // Do the work specific to the stopping target.
    void doStoppingTarget(const art::Event& event);

    // A helper function.
    int countHitNeighbours( Straw const& straw,
                            art::Handle<StepPointMCCollection>& hits );

  };
  ReadStoppedPis::ReadStoppedPis(fhicl::ParameterSet const& pset) :

    // Run time parameters
    _diagLevel(pset.get<int>("diagLevel",0)),
    _g4ModuleLabel(pset.get<string>("g4ModuleLabel")),
    _generatorModuleLabel(pset.get<string>("generatorModuleLabel")),
    _targetStepPoints(pset.get<string>("targetStepPoints","stoppingtarget")),
    _minimumEnergy(pset.get<double>("minimumEnergy")),
    _maxFullPrint(pset.get<int>("maxFullPrint",5)),
    _xyHitsMax(pset.get<int>("xyHitsMax",10000)),
    _pionsOnly(pset.get<bool>("pionsOnly",false)),
    _primariesOnly(pset.get<bool>("primariesOnly",false)),
    // Histograms
    _hTargetEdep(0),
    _hTargetPathLength(0),
    _hTargetNfoils(0),
    _hTargetNfoils2D(0),
    _ntup(0),
    _pionTargNtup(0),
    _xyHits(0),
    _xyHitCount(0),
    // Remaining member data
    _nBadG4Status(0),
    _nBadSimsAtTargetHandle(0)
  {
  }

  std::string pionTargetNtupleDescriptor() {
    std::string d;
    d = "evt:";         //   0  event.id()
// Information directly in SimParticle
    d += "pdgId:";      //   1  pdgID()
    d += "prm:";        //   2  isPrimary()
    d += "sec:";        //   3  isSecondary()
    d += "endX:";       //   4  endPosition().x()  
    d += "endY:";       //   5  endPosition().y()  
    d += "endZ:";       //   6  endPosition().z()  
    d += "endPx:";      //   7  endMomentum().x()  
    d += "endPy:";      //   8  endMomentum().y()  
    d += "endPz:";      //   9  endMomentum().z()  
    d += "endE:";       //  10  endMomentum().t()  
    d += "endT:";       //  11  endGlobalTime()  
    d += "endTau:";     //  12  endProperTime()  
    d += "endVol:";     //  13  endVolumeIndex()  
    d += "endG4stat:";  //  14  endG4Status()  
    d += "stopCode:";   //  15  stoppingCode()  
    d += "startX:";     //  16  startPosition().x()  
    d += "startY:";     //  17  startPosition().y()  
    d += "startZ:";     //  18  startPosition().z()  
    d += "startPx:";    //  19  startMomentum().x()  
    d += "startPy:";    //  20  startMomentum().y()  
    d += "startPz:";    //  21  startMomentum().z()  
    d += "startE:";     //  22  startMomentum().t()  
    d += "startT:";     //  23  startGlobalTime()  
    d += "startTau:";   //  24  startProperTime()  
    d += "startVol:";   //  25  startVolumeIndex()  
    d += "startG4stat:";//  26  startG4Status()  
    d += "createCode:"; //  27  creationCode()  
    d += "plsE:";       //  28  preLastStepKineticEnergy()  
    d += "nsteps:";     //  29  nSteps()  
    d += "weight:";     //  30  weight()  
    d += "endDef";      //  31  endDefined()  
// Derived information
// Planned (maybe) --
//    d += "startX:";     //   0  startPosition().x()  primary pions only 
//    d += "startY:";     //   0  startPosition().y()  primary pions only 
//    d += "startZ:";     //   0  startPosition().z()  primary pions only 
   
// When adding to this list, don't forget:
//      The last item should NOT have the ending colon :
//      The size of the nt array is automatically adjusted, but...
//      The numbers are NOT automatically kept in synch.  That is why the
//      numbers are commented here.  Keep this correct, and use it.
      
    return d;
  }
  void ReadStoppedPis::beginJob(){

    // Get access to the TFile service.
    art::ServiceHandle<art::TFileService> tfs;

    // Create stopping target histograms

    _hTargetEdep = tfs->make<TH1F>( "hTargetEdep",
                                    "Energy deposition in the stopping target",
                                    100, 0., 5. );
    _hTargetPathLength = tfs->make<TH1F>( "hTargetPathLength",
                                          "Path length in the stopping target",
                                          100, 0., 5. );
    _hTargetNfoils = tfs->make<TH1F>( "hTargetNfoils",
                                      "Number of stopping target foils crossed by particle",
                                      20, 0., 20. );
    _hTargetNfoils2D = tfs->make<TH2F>( "hTargetNfoils2D",
                                        "Number of stopping target foils vs foil of origin",
                                        20, 0., 20., 20, 0, 20. );

    // Create tracker ntuple.
    // _ntup = tfs->make<TNtuple>( "ntup", "Hit ntuple",
    //                                      "evt:trk:sid:hx:hy:hz:wx:wy:wz:dca:time:dev:sec:lay:pdgId:genId:edep:p:step:hwz");

    // Create target pions ntuple.
    _pionTargNtup = tfs->make<TNtuple> ( 
        "piontargntup", 
        "Pion target ntuple",
         pionTargetNtupleDescriptor().c_str()  );

    // Create a TGraph;
    // - Syntax to set name and title is weird; that's just root.
    // - Must append to the output file by hand.
    _xyHits = tfs->make<TGraph>(_xyHitsMax);
    _xyHits->SetName("xyHits");
    _xyHits->SetTitle("Y vs X for StepPointMC");
    gDirectory->Append(_xyHits);
 
  }

  void ReadStoppedPis::analyze(const art::Event& event) {

    mf::LogPrint ("newEvent") << "FilterStoppedPis begin event " <<event.id();

    // Maintain a counter for number of events seen.
    ++_nAnalyzed;

    // Inquire about the completion status of G4.
    art::Handle<StatusG4> g4StatusHandle;
    event.getByLabel( _g4ModuleLabel, g4StatusHandle);
    StatusG4 const& g4Status = *g4StatusHandle;
    if ( _nAnalyzed < _maxFullPrint ){
      cerr << g4Status << endl;
    }

    // Abort if G4 did not complete correctly.
    // Use your own judgement about whether to abort or to continue.
    if ( g4Status.status() > 1 ) {
      ++_nBadG4Status;
      mf::LogError("G4")
        << "Aborting ReadStoppedPis::analyze due to G4 status\n"
        << g4Status;
      return;
    }

    doStoppingTarget(event);

  }

  //
  // Reading information about stopping target
  //
  // Here we assume that the primary particles are the pions
  // saved at VD5.
  //
  void ReadStoppedPis::doStoppingTarget(const art::Event& event) {

    // Find original G4 steps in the stopping target
    art::Handle<StepPointMCCollection> sthits;
    event.getByLabel(_g4ModuleLabel,_targetStepPoints,sthits);

    // Find the SimParticles that step 2 (normally g4run2) produced 
    // - these were pions going from VD5 some of which stop in target 
    art::Handle<SimParticleCollection> sims2p;  // sims2
    event.getByLabel(_g4ModuleLabel,sims2p);

    if ( sims2p->empty() ) {
      mf::LogPrint("empty") << "simsAtTargetHandle->empty() for this event";
      // TODO - will eventually take this message out
      return;
    }
    SimParticleCollection const & sims2(*sims2p);

    // TODO - Also find the simparticles from g4run1, at the exit of TS5.

    // SimParticles container
    art::Handle<SimParticleCollection> simParticles;
    event.getByLabel(_g4ModuleLabel,simParticles);
    if( !(simParticles.isValid()) || simParticles->empty() ) return;

    float nt[_pionTargNtup->GetNvar()];  // Automatic array size adjustment

    // Loop over all sim particles (from the run from window to target)
    SimParticleCollection::const_iterator i = sims2.begin();
    SimParticleCollection::const_iterator e = sims2.end();
    for ( ; i!=e; ++i ) {
      // Alias, used for readability.  // Warning - may not really be a pion!
      SimParticle const & pion = i->second;

      // TODO - may want to create secondary ntuples with just primary pions
      //        or provide fcl control to do this filtering here.
      
      nt[0]  = event.id().event();
      nt[1]  = pion.pdgId();
      nt[2]  = pion.isPrimary();
      nt[3]  = pion.isSecondary();
      CLHEP::Hep3Vector stopPos = pion.endPosition();
      nt[4]  = stopPos.x();
      nt[5]  = stopPos.y();
      nt[6]  = stopPos.z();
      CLHEP::HepLorentzVector stopMom =  pion.endMomentum();      
      nt[7]  = stopMom.x();
      nt[8]  = stopMom.y();
      nt[9]  = stopMom.z();
      nt[10]  = stopMom.t();
      nt[11]  = pion.endGlobalTime();
      nt[12]  = pion.endProperTime();
      nt[13]  = pion.endVolumeIndex();
      nt[14] = pion.endG4Status();
      nt[15] = pion.stoppingCode();
      CLHEP::Hep3Vector startPos = pion.startPosition();
      nt[16] = startPos.x();
      nt[17] = startPos.y();
      nt[18] = startPos.z();
      CLHEP::HepLorentzVector startMom =  pion.startMomentum();      
      nt[19]  = startMom.x();
      nt[20]  = startMom.y();
      nt[21]  = startMom.z();
      nt[22]  = startMom.t();
      nt[23] = pion.startGlobalTime();
      nt[24] = pion.startProperTime();
      nt[25] = pion.startVolumeIndex();
      nt[26] = pion.startG4Status();
      nt[27] = pion.creationCode();
      nt[28] = pion.preLastStepKineticEnergy();
      nt[29] = pion.nSteps();
      nt[30] = pion.weight();
      nt[31] = pion.endDefined();

      int piMinusCode = -211; 
      bool isPiMinus = (pion.pdgId() == piMinusCode);
      if ( (!_primariesOnly) || pion.isPrimary() ) {
        if ( (!_pionsOnly) || isPiMinus ) {
        _pionTargNtup->Fill(nt);
        }
      }
    }
    
    // Loop over all hits in the stopping target. Check, that the
    // hit belongs to primary particle. If so, calculate total energy
    // deposition in the target, total path length and the number of
    // foils, crossed by the electron.

    int id_start = -1;
    double eDep=0.0, pathLength=0.0;
    map<int,int> foils;

    // Loop over all hits in the stopping target
    for ( size_t i=0; i<sthits->size(); ++i ){

      // This is G4 hit (step) in the target
      const StepPointMC& hit = (*sthits)[i];

      // Here we select only those hits, which are generated by
      // the primary track - which is assumed to be the original
      // particle, generated by ConversionGun
      SimParticleCollection::key_type trackId = hit.trackId();
      if( trackId.asInt() != 1 ) continue;

      // Here we require that there is information about the primary
      // particle in the SimParticle collection. It is not neccessary for
      // this example, but it is typical requirement in the real analysis
      SimParticle const* sim = simParticles->getOrNull(trackId);
      if( !sim ) continue;

      // Get the foil id where the hit occured. If it is the first hit,
      // remember this id as the source foil id.
      int id = hit.volumeId();
      if( id_start<0 ) id_start=id;

      // Here we calculate number of steps in each foil. There could be
      // many hits in each foil. This number is not used in the example,
      // it is calculated here just as an example. But we use this map to
      // calculate number of foils with the hits. Be aware, that if particle
      // crosses foil without energy deposition (just passes it), it still
      // counts as a hit. Here we record all foils particle crosses.
      // If we want to record only those foils where particle had
      // interactions, we would need to do the following:
      //      if( hit.totalEDep()>0 ) foils[id]++;
      foils[id]++;

      // Calculate total energy loss and path length primary particle
      // has in the target.
      eDep += hit.totalEDep();
      pathLength += hit.stepLength();

    }

    // Number of crossed foils
    int nfoil = foils.size();

    // Fill histograms
    if( id_start>=0 ) {
      _hTargetEdep->Fill(eDep);
      _hTargetPathLength->Fill(pathLength);
      _hTargetNfoils->Fill(nfoil);
      _hTargetNfoils2D->Fill(id_start,nfoil);
    }

  } // end doStoppingTarget

  void ReadStoppedPis::endJob(){
    cout << "ReadStoppedPis::endJob Number of events skipped "
         << "due to G4 completion status: "
         << _nBadG4Status
         << endl;
  }


}  // end namespace mu2e

DEFINE_ART_MODULE(mu2e::ReadStoppedPis);
