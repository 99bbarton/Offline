
#ifndef __GNUC__
extern "C" double lgamma(double);
#endif

#include <math.h>
#include <csignal>
#include <iostream>
#include "CDFFitting/inc/ConfidenceLevelComputer.hh"

inline double ConfidenceLevelComputer::getConfidenceLevel(double chiSquared, unsigned int degreesOfFreedom)
{
  if (chiSquared<0) {
    std::cerr << "Warning in ConfidenceLevelComputer, negative chiSquared"
              << std::endl;
    return 0;
  }
  return 1.0-gammp(degreesOfFreedom/2.0,chiSquared/2.0);
}





/*---------------------Incomplete gamma function---------------*/

inline float  ConfidenceLevelComputer::gammp(float a,float x)
{
    float LogGamma;
    if (x<0.0 || a<= 0.0) raise(SIGFPE);
    LogGamma = lgamma(a);
    if (x < (a+1.0))
        return gamser(a,x,LogGamma);
    else
        return 1.0-gammcf(a,x,LogGamma);
}

/*---------------------Incomplete gamma function complement----*/

inline float  ConfidenceLevelComputer::gammq(float a, float x)
{
    float LogGamma;
    if (x<0.0 || a<= 0.0) raise(SIGFPE);

    LogGamma =  lgamma(a);
    if (x < (a+1.0))
        return 1.0 - gamser(a,x,LogGamma);
    else
        return gammcf(a,x,LogGamma);
}

/* ------------------Incomplete gamma function-----------------*/
/* ------------------via its series representation-------------*/

inline float  ConfidenceLevelComputer::gamser(float a, float x, float LogGamma)
{
    float n;
    float ap,del,sum;

    ap=a;
    del=sum=1.0/a;
    for (n=1;n<ITMAX;n++) {
        ++ap;
        del *= x/ap;
        sum += del;
        if (fabs(del) < fabs(sum)*EPS) return sum*exp(-x + a*log(x) - LogGamma);
    }
    raise(SIGFPE);
    return 0;
}

/* ------------------Incomplete gamma function complement------*/
/* ------------------via its continued fraction representation-*/

inline float  ConfidenceLevelComputer::gammcf(float a, float x, float LogGamma) {

    float an,b,c,d,del,h;
    int i;

    b = x + 1.0 -a;
    c = 1.0/FPMIN;
    d = 1.0/b;
    h = d;
    for (i=1;i<int(ITMAX);i++) {
        an = -i*(i-a);
        b+=2.0;
        d=an*d+b;
        if (fabs(d) < FPMIN) d = FPMIN;
        c = b+an/c;
        if (fabs(c) < FPMIN) c = FPMIN;
        d = 1.0/d;
        del=d*c;
        h *= del;
        if (fabs(del-1.0) < EPS) return exp(-x+a*log(x)-LogGamma)*h;
    }
    raise(SIGFPE);
    return 0;
}

