#define MAXFILTERITERATION 1
#define MAXFILTERTOLERANCE 0.1
#define MAXCHISQDOF        1000
template <class Measureable>
ProgressiveFitter<Measureable>::ProgressiveFitter()
  :_chiSquared(0.0),
   _degreesOfFreedom(0),
   _numAppliedFitActions(0),
   _fit(NULL)
{
}

template <class Measureable>
ProgressiveFitter<Measureable>::ProgressiveFitter(const ProgressiveFitter<Measureable> &right)
  :_estimate(right._estimate),
   _covariance(right._covariance),
   _chiSquared(right._chiSquared),
   _degreesOfFreedom(right._degreesOfFreedom),
   _numAppliedFitActions(right._numAppliedFitActions),
   _residual(right._residual),
   _residualCov(right._residualCov),
   _errorMatrix(right._errorMatrix),
   _derivativeMatrix(right._derivativeMatrix),
   _displacementVector(right._displacementVector)
{
  if (right._fit) _fit=new Fit<Measureable>(*right._fit);
}


template <class Measureable>
ProgressiveFitter<Measureable>::~ProgressiveFitter()
{
  if (_fit) delete _fit;
  _fit=NULL;
}


template <class Measureable>
const ProgressiveFitter<Measureable> & ProgressiveFitter<Measureable>::operator=(const ProgressiveFitter<Measureable> &right)
{
  if (this != & right) {
    _estimate=right._estimate;
    _covariance=right._covariance;
    _chiSquared=right._chiSquared;
    _degreesOfFreedom=right._degreesOfFreedom;
    _numAppliedFitActions=right._numAppliedFitActions;
    _residual=right._residual;
    _residualCov=right._residualCov;
    _errorMatrix=right._errorMatrix;
    _derivativeMatrix=right._derivativeMatrix;
    _displacementVector=right._displacementVector;
    if (right._fit) {
      if (_fit) {
	*_fit=*right._fit;
      }
      else {
	_fit = new Fit<Measureable>(*right._fit);
      }
    }
    else {
      if (_fit) delete _fit;
      _fit=NULL;
    }
  }
  return *this;
}


template <class Measureable>
void ProgressiveFitter<Measureable>::apply(const FitAction<Measureable> *action)
{
  std::cerr << "Warning: Progressive fitter ignoring unknown fit action!" << std::endl;
}



template <class Measureable>
unsigned int ProgressiveFitter<Measureable>::getNumAppliedFitActions() const
{
  return _numAppliedFitActions;
}

template <class Measureable>
void ProgressiveFitter<Measureable>::fit()
{
  // Check that both a parametrization and a reference value
  // of the fitted object exists!
  if (!Fitter<Measureable>::getReference()) {
    std::cerr << "Ominious warning in Progressive Fitter: no reference value of measureable has been provided.  Skipping fit" <<std::endl;
    return;
  }
  //
  // if the data has already been fit, then reset the fit
  //
  if (_fit || _numAppliedFitActions) resetFit();
  //
  // apply all fit actions simultaneously
  //
  _degreesOfFreedom = -Measureable::getParameterSpaceSize();
  //
  for (int i=getNumAppliedFitActions();i<Fitter<Measureable>::getNumFitActions();i++) {
    Fitter<Measureable>::getFitAction(i)->applyYourselfTo(this);
    if (Fitter<Measureable>::failed()) return;
  }
  if (!_fit) {
    _fit=new Fit<Measureable>(_chiSquared,_degreesOfFreedom,_estimate,_covariance);
  }
  else {
    *_fit= Fit<Measureable>(_chiSquared,_degreesOfFreedom,_estimate,_covariance);
  }
}

template <class Measureable>
void ProgressiveFitter<Measureable>::apply(const Measurement<Measureable> *measurement)
{
  int error;
  double       deltaChiSquared;
  unsigned int   parDim                   = Measureable::getParameterSpaceSize();
  unsigned int   meaDim                   = measurement->getDimensionality();

  _errorMatrix        = measurement->getErrorMatrix(*Fitter<Measureable>::getReference());
  _derivativeMatrix   = measurement->getDerivativeMatrix(*Fitter<Measureable>::getReference());
  _displacementVector = measurement->getDisplacementFrom(*Fitter<Measureable>::getReference());
  HepMatrix    & H                  = _derivativeMatrix;     // For convenience

  //
  // Check that the dimensionality is right:
  //
  bool dimensionalityError=false;
  if (_derivativeMatrix.num_row()               != meaDim)  dimensionalityError=true;
  if (_derivativeMatrix.num_col()               != parDim)  dimensionalityError=true;
  if (_displacementVector.num_row()             != meaDim)  dimensionalityError=true;
  if (_errorMatrix.num_row()                    != meaDim)  dimensionalityError=true;
  //
  // Print an ominous warning in case the dimension of certain matrices is wrong.
  //
  if (dimensionalityError) {
    std::cerr << "Omininous warning in KalmanFitter:  a dimension error has occurred and a measurement has been skipped!" << std::endl;
    return;
  }
  for (int iteration=0;iteration<MAXFILTERITERATION;iteration++) {
    //
    // perform an innovation
    //
    HepMatrix   H_t      = H.T();

    HepMatrix   K        = _covariance*H_t*((_errorMatrix+H*_covariance*H_t).inverse(error));
    if (error) {
      std::cerr << "Ominous Warning in KalmanFitter::apply(Measurement):  matrix inversion failure " << std::endl;
      resetFit();
      Fitter<Measureable>::setFailed(true);
      return;
    }
    HepMatrix   K_t      = K.T();
    HepMatrix   Q        = (HepDiagMatrix(H.num_row(),1)-H*K);
    HepMatrix   P        = (HepDiagMatrix(K.num_row(),1)-K*H);
    HepMatrix   P_t      = P.T();
    _covariance.assign(P*_covariance*P_t + K*_errorMatrix*K_t);
    _estimate = _estimate + K*(_displacementVector);
    _residual     =  Q*(_displacementVector);
    _residualCov.assign(Q*_errorMatrix);
    deltaChiSquared = (_residual.T()*_residualCov.inverse(error)*_residual)[0];

    if (deltaChiSquared/meaDim > MAXCHISQDOF) {
	std::cerr << "Ominous Warning in KalmanFitter::apply(Measurement):  chi^2/dof=" << deltaChiSquared/meaDim << std::endl;
	resetFit();
	Fitter<Measureable>::setFailed(true);
        return;
    }

    //
    // Noninvertible residual covariance <==> deltaChiSquared virtually zero.
    //
    if (error) deltaChiSquared=0.0;

    // test for convergence.  Has the reference value shifted by more than the tolerance?
    if (iteration!=MAXFILTERITERATION) {
      HepVector dd=_estimate-Fitter<Measureable>::getReference()->getParameters();
      *Fitter<Measureable>::getReference()=Measureable::create(_estimate);
      if ((dd.T()*_covariance.inverse(error)*dd)[0] > MAXFILTERTOLERANCE*_covariance.num_row()) {
	_errorMatrix        = measurement->getErrorMatrix(*Fitter<Measureable>::getReference());
        _derivativeMatrix   = measurement->getDerivativeMatrix(*Fitter<Measureable>::getReference());
        _displacementVector = measurement->getDisplacementFrom(*Fitter<Measureable>::getReference());
        continue;
      }
      if (error) {
        std::cerr << "Ominous Warning in KalmanFitter::apply(Measurement):  matrix inversion failure " << std::endl;
	resetFit();
	Fitter<Measureable>::setFailed(true);
        return;
      }
      break;
    }
    else {
      *Fitter<Measureable>::getReference()=Measureable::create(_estimate);
    }
  }
  //
  // package
  //
  _chiSquared+=deltaChiSquared;
  _degreesOfFreedom+=meaDim;


}

template <class Measureable>
void ProgressiveFitter<Measureable>::apply(const Constraint<Measureable> *constraint)
{
  std::cerr << "Warning: constraints are not yet incorporated byt the ProgressiveFitter!" << std::endl;
}

template <class Measureable>
void ProgressiveFitter<Measureable>::apply(const Scatter<Measureable> *scatter)
{
  _covariance += scatter->getScatterMatrix(*Fitter<Measureable>::getReference());
}

template <class Measureable>
void ProgressiveFitter<Measureable>::apply(const Transport<Measureable> *transport)
{
  _estimate = transport->getTransportMatrix(*Fitter<Measureable>::getReference()) * _estimate;
  *Fitter<Measureable>::getReference()=Measureable::create(_estimate);
}

template <class Measureable>
void ProgressiveFitter<Measureable>::apply(const StartingPoint<Measureable> *startingPoint)
{
  if (Fitter<Measureable>::getFitAction(0) != startingPoint) {
    std::cerr << "Warning:  starting point must be the first action" << std::endl;
    return;
  }
  _covariance=startingPoint->getErrorMatrix(*Fitter<Measureable>::getReference());
  _estimate=Fitter<Measureable>::getReference()->getParameters();
}

template <class Measureable>
bool ProgressiveFitter<Measureable>::incorporateNextAction()
{
  //
  // Check that a reference value of the fitted object exists!
  //
  if (!Fitter<Measureable>::getReference()) {
    std::cerr << "Ominious warning in Progressive Fitter: no reference value of measureable has been provided.  Skipping fit" <<std::endl;
    return 0;
  }
  if (getNumAppliedFitActions()==0) _degreesOfFreedom = -Measureable::getParameterSpaceSize();
  if (Fitter<Measureable>::getNumFitActions() == getNumAppliedFitActions()) {
    return 0;
  }
  else {
    getFitAction(getNumAppliedFitActions())->applyYourselfTo(this);
  }
  if (!_fit) {
    _fit=new Fit<Measureable>(_chiSquared,_degreesOfFreedom,_estimate,_covariance);
  }
  else {
    *_fit= Fit<Measureable>(_chiSquared,_degreesOfFreedom,_estimate,_covariance);
  }
  return 1;
}

template <class Measureable>
const Fit<Measureable> * ProgressiveFitter<Measureable>::getFit() const
{
  return _fit;
}

template <class Measureable>
const Residual * ProgressiveFitter<Measureable>::newResidual(const Measurement<Measureable> *measurement)
{
  if (!_fit) return NULL;
  unsigned int length=measurement->getDimensionality();
  for (int i=0;i<Fitter<Measureable>::getNumFitActions();i++) {
    if (measurement==Fitter<Measureable>::getFitAction(i)) {
      const HepSymMatrix    error        = measurement->getErrorMatrix(*Fitter<Measureable>::getReference());
      const HepMatrix       derivatives  = measurement->getErrorMatrix(*Fitter<Measureable>::getReference());
      const HepVector       displacement = measurement->getDisplacementFrom(*Fitter<Measureable>::getReference());
      HepSymMatrix cov;
      cov.assign(error-derivatives.T()*_covariance*derivatives);
      return new Residual(displacement,cov);
    }
  }
  return NULL;
}


// Additional Declarations
template <class Measureable>
void ProgressiveFitter<Measureable>::resetFit() {
  if (_fit) {
    delete _fit;
    _fit=NULL;
  }
  _chiSquared=0;
  _numAppliedFitActions=0;
  _degreesOfFreedom=0;
}
