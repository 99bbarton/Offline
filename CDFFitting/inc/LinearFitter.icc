
template <class Measureable>
LinearFitter<Measureable>::LinearFitter()
  :_numAppliedFitActions(0),
   _fit(NULL),
   _degreesOfFreedom(0)
{
}

 template <class Measureable>
LinearFitter<Measureable>::LinearFitter(const LinearFitter<Measureable> &right)
  :_numAppliedFitActions(right._numAppliedFitActions),
   _derivatives(right._derivatives),
   _weight(right._weight),
   _residuals(right._residuals),
   _constraintMatrices(right._constraintMatrices),
   _measurementPtr(right._measurementPtr),
   _degreesOfFreedom(right._degreesOfFreedom)
{
  if (right._fit) _fit=new Fit<Measureable>(*right._fit);
}


template <class Measureable>
LinearFitter<Measureable>::~LinearFitter()
{
  if (_fit) delete _fit;
  _fit=NULL;
}


template <class Measureable>
const LinearFitter<Measureable> & LinearFitter<Measureable>::operator=(const LinearFitter<Measureable> &right)
{
  if (this!=&right) {
    Fitter<Measureable>::operator=(right);
    _numAppliedFitActions=right._numAppliedFitActions;
    _derivatives=right._derivatives;
    _weight=right._weight;
    _residuals=right._residuals;
    _constraintMatrices=right._constraintMatrices;
    _measurementPtr=right._measurementPtr;
    _degreesOfFreedom=right._degreesOfFreedom;
    if (right._fit) {
      if (_fit) {
	*_fit = *(right._fit);
      }
      else {
	_fit = new Fit<Measureable>(*right._fit);
      }
    }
    else {
      if (_fit) delete _fit;
      _fit=NULL;
    }
  }
  return *this;
}


template <class Measureable>
unsigned int LinearFitter<Measureable>::getNumAppliedFitActions() const
{
  return _numAppliedFitActions;
}

template <class Measureable>
void LinearFitter<Measureable>::fit()
{
  _status = 1; // ok
  int error;
  if (!Fitter<Measureable>::getReference()) {
    std::cerr << "Ominious warning in Linear Fitter: no reference value of measurable has been provided.  Skipping fit" <<std::endl;
    _status = 0;
    return ;
  }
  //
  // if the data has already been fit, then reset the fit
  //
  if (_fit || _numAppliedFitActions) resetFit();
  //
  // apply all fit actions simultaneously
  //
  _degreesOfFreedom = -Measureable::getParameterSpaceSize();
  for (int i=0;i<Fitter<Measureable>::getNumFitActions();i++) {
    Fitter<Measureable>::getFitAction(i)->applyYourselfTo(this);
  }
  //
  // if the fit is underconstrained, then just return.  There is no fit.
  //
  if (_degreesOfFreedom<0) { _status = 0; return ; }
  //
  // calculate the fit result without constraints.
  //
  HepMatrix             A                      = _derivatives;
  HepMatrix             A_t                    = A.T();
  const HepMatrix       V_y                    = _weight;
  HepMatrix             V_y_i                  = V_y.inverse(error);
  if (error) {
    std::cerr << "Ominous Warning in LinearFitter::fit():  matrix inversion failure location 0" << std::endl;
    _status = 0;
    return ;
  }
  HepSymMatrix         covariance;
  covariance.assign( A_t*V_y_i*A);
  HepSymMatrix         V_a                    = covariance.inverse(error);
  if (error) {
    std::cerr << "Ominous Warning in LinearFitter::fit():  matrix inversion failure location 1" << std::endl;
    _status = 0;
    return ;
  }
  HepVector    eta           = V_a*A_t*V_y_i*_residuals;
  HepVector    estimate      = Fitter<Measureable>::getReference()->getParameters() + eta;
               _residuals   -= A*eta;
  double       chiSquared    = (_residuals.T()*V_y*_residuals)[0];
  HepSymMatrix errorMatrix_i;
  errorMatrix_i.assign(A_t*V_y*A);
  HepSymMatrix errorMatrix   = errorMatrix_i.inverse(error);
  if (error) {
    std::cerr << "Ominous Warning in LinearFitter::fit():  matrix inversion failure " << std::endl;
    _status = 0;
    return ;
  }

  //
  // now add in the constraints, if any.
  //

  if (_constraintVectors.num_row() !=0) {
    // prepare
    HepVector              eta0       = eta;
    const HepMatrix        V_eta0     = V_a;
    HepMatrix              D          = _constraintMatrices;
    HepMatrix              D_t        = D.T();
    HepVector              d          = _constraintVectors;
    // solve
    HepMatrix              V_d_i      = (D*V_eta0*D_t);
    HepMatrix              V_d        = V_d_i.inverse(error);
    if (error) {
      std::cerr << "Ominous Warning in LinearFitter::fit():  matrix inversion failure " << std::endl;
      _status = 0;
      return ;
    }
    HepVector              lambda     = V_d*(D*eta0+d);
    HepMatrix              V_eta      = V_eta0 - V_eta0*D_t*V_d*D*V_eta0;

    // package
    /*HepVector*/          eta        = eta0 - V_eta0*D_t*lambda;
    /*HepMatrix*/          covariance.assign(V_eta.inverse(error));
    if (error) {
      std::cerr << "Ominous Warning in LinearFitter::fit():  matrix inversion failure " << std::endl;
      _status = 0;
      return ;
    }
    /*double   */          chiSquared = (lambda.T()*V_d_i*lambda)[0];
  }

  //
  // construct the fit result.
  //

  if (_degreesOfFreedom >= 0) {
    _fit=new Fit<Measureable>(chiSquared,_degreesOfFreedom,estimate,errorMatrix);
  }
  *Fitter<Measureable>::getReference()=Measureable::create(estimate);
  return ;
}


template <class Measureable>
void
LinearFitter<Measureable>::apply(const Scatter<Measureable> *) {
  std::cerr << "Warning: Linear fitter ignoring scatter fit action!" << std::endl;

}

template <class Measureable>
void
LinearFitter<Measureable>::apply(const StartingPoint<Measureable> *) {
  std::cerr << "Warning: Linear fitter ignoring starting point fit action!" << std::endl;

}

template <class Measureable>
void
LinearFitter<Measureable>::apply(const Transport<Measureable> *) {
  std::cerr << "Warning: Linear fitter ignoring transport fit action!" << std::endl;

}

template <class Measureable>
void
LinearFitter<Measureable>::apply(const FitAction<Measureable> *) {
  std::cerr << "Warning: Linear fitter ignoring unknown fit action!" << std::endl;

}


template <class Measureable>
void
LinearFitter<Measureable>::apply(const Measurement<Measureable> *measurement)
{
  int error;
  //
  // Access everything you need from the measurement.
  //
  const HepSymMatrix   errorMatrix        = measurement->getErrorMatrix(*Fitter<Measureable>::getReference());
  const HepMatrix      derivativeMatrix   = measurement->getDerivativeMatrix(*Fitter<Measureable>::getReference());
  const HepVector      displacementVector = measurement->getDisplacementFrom(*Fitter<Measureable>::getReference());
  unsigned int         parDim             = Measureable::getParameterSpaceSize();
  unsigned int         meaDim             = measurement->getDimensionality();
  //
  // Check that the dimensionality is right:
  //
  bool dimensionalityError=false;
  if (derivativeMatrix.num_row()               != meaDim)  dimensionalityError=true;
  if (derivativeMatrix.num_col()               != parDim)  dimensionalityError=true;
  if (displacementVector.num_row()             != meaDim)  dimensionalityError=true;
  if (errorMatrix.num_row()                    != meaDim)  dimensionalityError=true;
  //
  // Print an ominous warning in case the dimension of certain matrices is wrong.
  //
  if (dimensionalityError) {
    std::cerr << "Omininous warning in LinearFitter:  a dimension error has occurred and a measurement has been skipped!" << std::endl;
    return ;
  }
  //
  // increase the number of degrees of freedom
  //
  _degreesOfFreedom+=meaDim;
  //
  // this is to keep track of the position of the residuals in the mega-matrix
  //
  _measurementPtr.push_back(meaDim);
  //
  // Make a matrix equal to the direct sum of weight matrices:
  //
  _weight=dsum(_weight,errorMatrix.inverse(error));
  if (error) {
    std::cerr << "Ominous Warning in LinearFitter::apply(Measurement):  matrix inversion failure " << std::endl;
    return;
  }
  //
  // Make a matrix equal to the direct sum of derivatives
  //
  if (_derivatives.num_row()==0) {
    _derivatives = derivativeMatrix;
  }
  else {
    HepMatrix newDerivative(
      _derivatives.num_row()+meaDim,_derivatives.num_col() );
    newDerivative.sub(1,1,_derivatives);
    newDerivative.sub(_derivatives.num_row()+1,1,derivativeMatrix);
    _derivatives=newDerivative;
  }
  //
  // Make a vector equal to the direct sum of residuals
  //
  _residuals=dsum(_residuals,displacementVector);
  //
  // increment the number of applied fit actions.
  //
  _numAppliedFitActions++;
  //
}

template <class Measureable>
void LinearFitter<Measureable>::apply(const Constraint<Measureable> *constraint)
{
  //
  // Access everything you need from the constraint.
  //
  HepMatrix     constraintMatrix   = constraint->getConstraintMatrix(*Fitter<Measureable>::getReference());
  HepVector     constraintVector   = constraint->getConstraintVector(*Fitter<Measureable>::getReference());
  unsigned int  parDim             = Measureable::getParameterSpaceSize();
  unsigned int  conDim             = constraint->getDimensionality();
  //
  // Check that the dimensionality is right:
  //
  bool dimensionalityError=false;
  if (constraintMatrix.num_row()               != conDim)  dimensionalityError=true;
  if (constraintMatrix.num_col()               != parDim)  dimensionalityError=true;
  if (constraintVector.num_row()               != conDim)  dimensionalityError=true;
  //
  // Print an ominous warning in case the dimension of certain matrices is wrong.
  //
  if (dimensionalityError) {
    std::cerr << "Omininous warning in LinearFitter:  a dimension error has occurred and a constraint has been skipped!" << std::endl;
    return;
  }
  //
  // increase the number of degrees of freedom
  //
  _degreesOfFreedom+=conDim;
  //
  // this is to keep track of the position of the residuals in the mega-matrix
  //
  _measurementPtr.push_back(conDim);
  //
  // Make a matrix equal to the direct sum of derivatives
  //
  HepMatrix newConstraint;
  newConstraint.sub(1,1,_constraintMatrices);
  newConstraint.sub(_constraintMatrices.num_row()+1,1,constraintMatrix);
  _constraintMatrices=newConstraint;
  //
  // Make a vector equal to the direct sum of residuals
  //
  _constraintVectors=dsum(_constraintVectors,constraintVector);
  //
  // increment the number of applied fit actions.
  //
  _numAppliedFitActions++;
  //
}

template <class Measureable>
const Fit<Measureable> * LinearFitter<Measureable>::getFit() const
{
  return _fit;
}

template <class Measureable>
const Residual * LinearFitter<Measureable>::newResidual(const Measurement<Measureable> *measurement)
{
  int error;
  if (!_fit) return NULL;
  unsigned int length=measurement->getDimensionality();
  unsigned int offset=1;
  unsigned int index=0;
  for (int i=0;i<Fitter<Measureable>::getNumFitActions();i++) {
    if (measurement==Fitter<Measureable>::getFitAction(i)) {
      // make and return a residual
      const HepVector         res= _residuals.sub(offset,offset+length);
      HepSymMatrix           cov=_weight.sub(offset,offset+length).inverse(error);
      if (error) {
	std::cerr << "Ominous Warning in LinearFitter::newResidual(Measurement):  matrix inversion failure " << std::endl;
	return NULL;
      }
      return new Residual(res,cov);
    }
    offset+=_measurementPtr[index++];
  }
  return NULL;
}


// Additional Declarations
template <class Measureable>
void LinearFitter<Measureable>::resetFit() {
  if (_fit) {
    delete _fit;
    _fit=NULL;
  }
  _numAppliedFitActions=0;
  _derivatives=HepMatrix();
  _weight     =HepSymMatrix();
  _residuals  =HepVector();
  _constraintMatrices =HepMatrix();
  _constraintVectors  =HepVector();
  _measurementPtr.erase(_measurementPtr.begin(),_measurementPtr.end());
  _degreesOfFreedom=0;
}




