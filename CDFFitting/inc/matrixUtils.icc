
#include "CLHEP/Matrix/Matrix.h"
#include "CLHEP/Matrix/SymMatrix.h"
#include "CLHEP/Matrix/Vector.h"
#define JACOBI_ROTATION(A,i,j,k,l) g=A[i][j]; h=A[k][l]; A[i][j] = g-s*(h+g*tau); A[k][l] = h + s*(g-h*tau);
inline HepMatrix jacobi(HepSymMatrix * Source) {

//  AS IN NUMERICAL RECIPES IN C, PAGE 467

  int irow,icol;
  float Threshold;

  int mtrxSize=Source->num_row();
  HepMatrix RotationMatrix =HepMatrix(mtrxSize,mtrxSize,1);
  HepVector EigenValues(mtrxSize,0);
  for (irow=0;irow<mtrxSize;irow++) EigenValues[irow]=(*Source)[irow][irow];
  HepVector Z(mtrxSize,0), B(EigenValues);
  int NumberRotations = 0;

  for (int Iteration=0;Iteration<50;Iteration++) {
    float SumOffDiagonal=0.0;
    for (irow=0;irow<mtrxSize;irow++) {
      for (icol=irow+1;icol<mtrxSize;icol++) {
	SumOffDiagonal+= fabs((*Source)[irow][icol]);
      }
    }
    if (SumOffDiagonal==0.0) break;
    if (Iteration<4)
      Threshold = 0.2*SumOffDiagonal/(mtrxSize*mtrxSize);
    else
      Threshold = 0.0;
    for (irow=0;irow<mtrxSize;irow++) {
      for (icol=irow+1;icol<mtrxSize;icol++) {
	float t,g;
	g = 100.0*fabs((*Source)[irow][icol]);
	if (Iteration>4 && (float) (fabs(EigenValues[irow])+g) == (float) fabs(EigenValues[irow]) && (float) (fabs(EigenValues[icol])+g) == (float) fabs(EigenValues[icol])) {
	  (*Source)[irow][icol]=0.0;
	}
	else if (fabs((*Source)[irow][icol])>Threshold) {
	  float h = EigenValues[icol] - EigenValues[irow];
	  if ((float) (fabs(h) + g) == (float) fabs(h)) {
	    t = (*Source)[irow][icol]/h;
	  }
	  else {
	    float Theta = 0.5*h/(*Source)[irow][icol];
	    t = 1.0/(fabs(Theta) + sqrt(1.0 + Theta*Theta));
	    if (Theta<0) t = -t;
	  }
	  float c = 1.0/sqrt(1.0+t*t);
	  float s = t*c;
	  float tau = s/(1.0 + c);
	  h = t*(*Source)[irow][icol];
	  Z[irow] -= h;
	  Z[icol] += h;
	  EigenValues[irow] -= h;
	  EigenValues[icol] += h;
	  (*Source)[irow][icol] = 0.0;

	  int j;
	  for (j=0;j<irow;j++) {
	    JACOBI_ROTATION((*Source),j,irow,j,icol)
	      }
	  for (j=irow+1;j<icol;j++) {
	    JACOBI_ROTATION((*Source),irow,j,j,icol)
	      }
	  for (j=icol+1;j<mtrxSize;j++) {
	    JACOBI_ROTATION((*Source),irow,j,icol,j)
	      }
	  for (j=0;j<mtrxSize;j++) {
	    JACOBI_ROTATION(RotationMatrix,j,irow,j,icol)
	      }
	  NumberRotations++;
	}
      }
    }
    B+=Z;
    EigenValues=B;
    Z=HepVector(mtrxSize,0);
  }
  for (int dd=0;dd<mtrxSize;dd++) (*Source)[dd][dd]=EigenValues[dd];
  return RotationMatrix;
}





